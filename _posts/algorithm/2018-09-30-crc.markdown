# CRC 校验

本文参考自 [A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS](http://www.ross.net/crc/download/crc_v3.txt)

CRC 算法用于校验数据在传输过程中是否有错误。

这种错误校验的一般方式是：发送方在发送数据前，会用某种算法对数据进行运算，得出一个校验码 checksum, 附在数据后面，接收方收到后，再用同样的算法对数据进行运算，然后检查运算得到的 checksum 和发过来的 checksum 是否一致，从而判断传过来的数据是否有错误。

Checksum 不可能和原来数据一样长度，往往是定长的一个码，还不能太大，不同的原始数据可能对应同一个 checksum, 并且接收方收到的 checksum 可能也是错误的。因此校验出错是无法避免的，但选取合适的 checksum 生成算法，可以让校验出错的概率更低，CRC 算法就是一个比较好的 checksum 生成算法。

为了说明上述问题，先来看一种简单的校验算法，它把数据的所有 byte 相加，然后对 256 取模:

```
Message                    :  6 23 4
Message with checksum      :  6 23 4  33
Message after transmission :  8 20 5  33
```

上述算法有两个问题：
1. checksum 的取值范围太小了(0 ~ 255), 在数据错误的情况下，有 1/256 的概率，checksum 无法发现数据是错的(因为有 1/256 的数据运算后等于这个 checksum);
2. 每个输入字节最多只能影响求和寄存器中的一个字节，上面的错误例子中，即使把 checksum 设为对 65536 取模，错误也无法检测出来;

所以对一个健壮的 checksum 运算方法来说，至少要关注两个方面：
- **WIDTH**: 寄存器应该足够宽，以降低出错概率;
- **CHAOS**: 输入的每个字节都应该有可能影响寄存器的任何 bit;


## 余数

CRC 算法的基本思路是把整个消息视为一个巨大的二进制数，然后用它对另一个固定的二进制数取余，取余结果作为 checksum.

示例:

假定数据是 (6, 23), 其16进制为 0617, 二进制为 0000-0110-0001-0111, 取余时所使用的除数为 1001, 所以 checksum 就是 0000-0110-0001-0111 对 1001 取余的结果。其计算过程可以参考下图，使用的是小学时候学过的手算除法的方法，只是从 10 进制换成了 2 进制:

```
          ...0000010101101 = 00AD =  173 = QUOTIENT    每计算一次向右移动一个 bit, 商记录在这里
         ____-___-___-___-
9= 1001 ) 0000011000010111 = 0617 = 1559 = DIVIDEND
DIVISOR   0000.,,....,.,,, 余数
          ----.,,....,.,,,
           0000,,....,.,,, 余数加上下一个 bit
           0000,,....,.,,, 余数
           ----,,....,.,,,
            0001,....,.,,, 余数加上下一个 bit
            0000,....,.,,, 余数
            ----,....,.,,,
             0011....,.,,,
             0000....,.,,,
             ----....,.,,,
              0110...,.,,,
              0000...,.,,,
              ----...,.,,,
               1100..,.,,,
               1001..,.,,,
               ====..,.,,,
                0110.,.,,,
                0000.,.,,,
                ----.,.,,,
                 1100,.,,,
                 1001,.,,,
                 ====,.,,,
                  0111.,,,
                  0000.,,,
                  ----.,,,
                   1110,,,
                   1001,,,
                   ====,,,
                    1011,,
                    1001,,
                    ====,,
                     0101,
                     0000,
                     ----
                      1011
                      1001
                      ====
                      0010 = 02 = 2 = REMAINDER
```

以 10 进制来表示，上述计算过程是 1559 除以 9 得 173 余 2.  观察上述计算过程可以发现，商的每个 bit 并不会受到所有输入的影响，但余数的生成却相关于整个计算过程。


## 多项式算数