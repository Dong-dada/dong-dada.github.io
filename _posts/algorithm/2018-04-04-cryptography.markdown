---
layout: post
title:  "密码学小知识点"
date:   2018-04-04 11:34:30 +0800
categories: algorithm
---

* TOC
{:toc}


## 数据安全中要考虑的问题

目前了解到的知识里，数据安全中要考虑三个问题：
- 保护数据不被别人窃听；
- 保护数据不被别人篡改；
- 保护身份不被别人冒充；


## 加解密算法

密码学解决上述两个问题的基础是加解密算法，分两类：

对称加密：
- 效率高；
- **破解难度大**；
- 密钥交换困难，只有一个密钥，安全地把它传给对方比较困难；

非对称加密：
- 效率低，RSA 相比 AES 慢几十倍甚至几百倍；
- **破解难度相对低**, RSA3027 仅相当于 AES128, 两者都是 O(2^128);
- 解决了密钥交换问题；

另外，在 **防读取** 这个问题上，非对称加密只能用公钥加密，用私钥解密，不能反过来。

单纯使用对称加密或非对称加密不能保障数据安全，需要在此基础上增加各种设施和机制来保障。


## 防窃听

### 单纯的非对称加密

非对称加密的工作过程：
- 向接收方拿到公钥 pub；
- 用 pub 对数据进行加密，发给接收方；
- 接收方用私钥 pri 进行解密；

这里的问题是非对称加密效率比较低。

### 数字信封

正如之前所说，对称加密效率高，但存在密钥交换困难的问题，非对称加密的特点是密钥分发方便，但效率低、破解难度地。因此使用单一的对称加密或非对称加密方法都不够实用。

数字信封的原理非常简单：
- 生成一个对称密钥 key, 用这个 key 对数据进行加密；
- 用接收方的 pub 对 key 进行加密，得到了一个信封；
- 把信封和密文一起发给接收方；
- 接收方收到之后用自己的 pri 解密信封，得到 key;
- 接收方用 key 对密文进行解密；

由于 key 本身不大，所以用非对称加解密都很快，如此一来就兼顾了效率与密钥分发。

### HTTPS 握手

HTTPS 是服务器客户端模式，相比于数字信封技术，客户端和服务器之间会先用明文交换两个随机数，然后客户端生成第三个随机数，用服务端的 pub 加密后发给服务端。之后双方通过三个随机数来生成一个对称密钥。

这里之所以要交换 3 个随机数来生成对称密钥，而不是客户端直接生成对称密钥，通过 pub 加密后发给服务器，是因为 SSL 不相信客户端的密钥生成器能生成足够随机的对称密钥，有可能被攻击者猜到生成规则。

通过随机数的机制，可以降低猜到规则的概率。


## 防篡改

### 消息认证码 MAC

MAC(Message Authentication Code, 消息认证码) 的作用在于保护数据不被伪造和篡改，与保护数据不被别人看到是两回事。

考虑上课的时候小明和小红传小纸条，小董从中捣乱篡改了小纸条上的内容，小红和小明分手了。MAC 要解决的是上述场景的问题，跟纸条上的内容是否是明文没有关系。

MAC 的计算使用了对称加密的思想，其思路是传入两个参数 message 和 key, 计算出一个 MAC, 把 message 和 MAC 一起发给对方，对方收到后再用 message‘ 和 key 计算出 MAC', 比较 MAC 和 MAC' 来确定 message 是否被篡改。

常见的 MAC 实现方式是 HMAC(Hash MAC), 即通过哈希算法来实现 MAC, 计算 Hash 值的时候需要传入一个 key.

MAC 的基础在于对称密钥 key, 所以他也存在着密钥交换的问题。

### 数字签名

数字签名利用了非对称加密的思想，可以解决 MAC 的秘钥交换问题。

1. 发送方发送数据前，先用非对称加密生成一对密钥 pri, pub, 然后把 pub 发给对方。
2. 发送方用 pri 对数据进行签名，发给接收方；
3. 接收方用 pub 对数据进行验签，如果验签失败，说明数据被篡改；

可以看到，RSA 算法不止可以加解密，还可以用来加签验签；


## 防冒充

上述讨论的内容中都存在中间人攻击问题，比如在数字签名的第一步，中间人可以自己生成密钥 pri', pub', 然后把 pub' 发给接收方，接收方始终能够验签成功，相信数据没有被篡改或伪造。

中间人攻击的关键问题是发送方的 pub 无法保障其身份的可信度。

### 数字证书

对于中间人攻击问题，一种解决方案是引入一个权威的第三方。类似于货币之所以有价值，是因为有政府为其背书，数字证书的原理也是这样，有几家认证机构，他们的身份是可信的。

- 发送方先生成一对密钥 pri, pub, 其中 pub 需要保障不被伪造；
- 发送方提交申请，认证机构审核完毕后，用自己的私钥 PRI 对 pub 进行签名，得到 ca_sign;
- 认证机构把证书 certificate = pub + ca_sign 颁发给发送方，相当于保障发送方的 pub 是可信的；
- 发送方把证书发给接收方；
- 接收方收到证书后，用认证机构的公钥 PUB 对证书中的 ca_sign 进行验签，确认 pub 是否可信；

通过引入认证机构的方式，就可以保障 pub 的可信度，相当于保障了发送方的身份不会被伪造。

数字证书一般需要结合数字签名一起使用，由数字签名保障数据不被篡改，由数字证书保障发送方的可信度。

实际情况中的认证机构有点类似于金字塔多级结构，除了几个顶级的认证机构以外，还有许多中间机构。通过一级一级的证书颁发来确保身份可信。

上述过程中有一个隐含假设，就是说认证机构的 pub 要安全地传递给接收方，否则就会出现中间人伪装自己是认证机构的情况。

解决上述问题的方式说来很普通，就是预先安装到用户的机器上，比如 Mac 电脑上就包含了 apple 自己的根证书。有段时间 12306 需要你自行安装根证书，就是因为 12306 所使用的证书没有被顶级机构认证过，电脑里没有默认安装，需要手动安装一下。


