---
layout: post
title:  "《软件调试》 学习 14 内核调试引擎"
date:   2017-05-11 10:29:30 +0800
categories: debugging
---

* TOC
{:toc}

简单来说，内核调试就是分析和调试位于内核空间中的代码和数据。运行在内核空间的模块主要有操作系统的内核、执行体和各种驱动程序。从操作系统的角度看，可以把驱动程序看做是对操作系统内核的扩展和补充。因此可以把内核调试简单地理解为操作系统的广义内核。

使用调试器调试的一个重要特征就是可以把调试目标中断到调试器中，换言之，当我们在调试器中分析调试目标时，调试目标是处于冻结状态的。

进行用户态调试的时候，被调试进程将被挂起。同样的，内核调试的时候，被调试的操作系统内核也将停止运行，接受调试器的分析和检查。这时候怎么对已经冻结的操作系统进行调试呢？

目前主要有三种方案来解决上述问题：
1. 使用硬件调试器，它可以通过特定的接口(如 JTAG)与 CPU 建立连接并读取它的状态；
2. 在内核中插入专门用于调试的中断处理函数和驱动程序，当系统内核被中断时，由这些中断处理函数和驱动程序来接管系统硬件，营造出一个可供调试器运行的简单环境；
3. 在内核中加入调试支持，当内核需要中断到调试器时，只保留这些代码还在运行。由另外一个操作系统与这些调试支持程序通信，完成调试功能。这两个操作系统间通过电缆连接；

Windows 操作系统推荐的内核调试方法是第三种。操作系统中内建的部分被称为内核调试引擎 (Kernel Debug Engine)；


## 概览

### KD

Windows 操作系统的每个系统部件中都有一个简短的名字，通常为两个字符，比如 MM 代表内存管理器，OB 代表对象管理器，PS 代表进程和线程管理，等等。同样的，内核调试引擎也有一个这样的名字，叫做 KD (Kernel Debug)。内核模块中用来支持内核调试的函数和变量大多都是以这两个字母开头的。

### 角色

从下图左侧可以看出，内核调试引擎是 内核调试器 与 被调试内核之间的桥梁。

![]( {{site.url}}/asset/software-debugging-kernel-debug-engine.png )

内核调试引擎 和 内核调试器 之间通过 内核调试协议 进行通信。通过这个协议，调试器可以请求调试引擎帮助它访问和控制目标系统，调试引擎也会主动将目标系统的状态报告给调试器。

从访问内核的角度看，内核调试引擎为内核调试器提供了一套特殊的 API，我们将其称为内核调试 API，简称 KdAPI。使用 KdAPI, 调试器可以以一种类似远程调用的方式访问到内核，这与应用程序通过 Win32 API 访问内核 (服务) 很类似。上图右侧更好地显示了 内核调试器、调试引擎、内核其他部分 这三者之间的关系。

### 组成

可以把内核调试引擎分为如下几个部分：

- **与系统内核的接口函数** 这是调试引擎向内核暴露的一些接口，内核会调用这些接口，来初始化引擎、让引擎处理异常、检查中断命令等。比如内核启动过程中会调用 KdInitSystem 来初始化内核调试引擎；内核分发异常时会调用 KdpTrap 或 KdpStub 等；
- **与调试器的通信函数** 负责与另一个系统中的调试器进行通信，包括建立和维护通信端口，收发数据包等；
- **断点管理** 负责记录所有断点，调试引擎使用一个数组来记录断点，其名称为 KdpBreakpointTable；
- **内核调试 API** 这是内核调试引擎与调试器之间的逻辑接口。之所以说是逻辑接口，是因为内核调试引擎和调试器不在同一个机器上，所以不可以直接调用。实际的做法是调试器通过数据包将要调用的 API 号码和参数传递给调试引擎，调试引擎收到后调用对应的函数，然后再把函数执行结果以数据包的形式返回给调试器。这些接口向调试器提供了许多支持，包括读写内存、读写 IO 空间、读取和设置上下文、设置和恢复断点等；
- **系统内核控制函数** 包括负责将系统内核中断到调试器的 KdEnterDebugger 函数，恢复系统运行的 KdExitDebugger 函数；
- **管理函数** 包括启用和禁止内核调试引擎的 KdEnableDebugger 和 KdDisableDebugger, 以及修改选项的 KdChangeOption. WinDBG 工具包中的 kdbgctrl 工具就是通过这些函数来工作的；
- **ETW 支持函数** 与 ETW 机制配合将追踪数据输出到调试器所在的主机上。负责这一功能的主要函数是 KdReportTraceData；
- **驱动程序更新服务** 从主机上读取驱动程序文件来更新被调试系统中的驱动程序；
- **本地内核调试支持** 包括 NtSystemDebugControl 和 KdSystemDebugControl ;

下图展示了这些部分的作用：

![]( {{site.url}}/asset/software-debugging-kernel-debug-engine-modules.png )

### 模块文件

这一小节介绍内核调试引擎所在的模块文件 (DLL) 文件。

在 Windows XP 之前，内核调试引擎的所有函数都位于 NT 内核文件中，即 NTOSKRNL.EXE, 从 Windows XP 开始，内核调试引擎中的通信部分被拆分到一个单独的 DLL 中，名为 KDCOM.DLL。


## 连接

这一节讨论调试器所在的系统如何与被调试系统建立连接。它们都是通过电缆连接在一起的，但是有 3 中不同的连接方式： 串行口、1394、USB 2.0，下面分别介绍它们：

### 串行口

串行通信 (Serial Communication) 是 Windows 内核调试的本位 (native) 通行方式。因为内核调试一开始就是针对串行通信设计的，所以直至今天，串行通信仍然是进行 Windows 内核调试的最稳定方式。这其中一个主要原因就是内核调试通信协议是面向字节而不是数据包定义的，而串行通信是最适合按字节来读写数据和同步的，其他的通信方式都是以数据包的形式来组织数据的。

### 1394

1394 又称火线，是一种高性能的串行总线通信标准。Windows XP 引入了使用这种接口来进行内核调试的支持。

### USB 2.0

USB 是 Universal Serial Bus 的缩写，是一种低成本高性能的串行总线标准。

USB 总线的节点连接具有方向性，USB 端口分为用于连接设备的上游 (upstream) 和用来连接主机的下游 (downstream) 端口。而一般个人电脑系统上的 USB 端口都是所谓的上游 (upstream) 端口。因为两个上游端口是无法简单连接而进行通信的，所以使用 USB 2.0 方式进行内核调试时，首先需要有一根特殊的 USB 2.0 主机到主机的电缆。

### 管道

虚拟机 (Virtual Machine) 技术可以在一台物理系统中构建出多个虚拟机，每个虚拟机可以安装和运行一个操作系统。

虚拟机技术的流行使人们很自然地想到可以利用它来进行内核调试。

接下来要考虑的问题是如何建立两个系统之间的通信连接。这需要使用软件的通信方式来模拟硬件通信端口，比如使用命名管道模拟串行端口。其做法是在虚拟机管理软件中使用命名管道虚拟出一个 COM 口，下图展示了这一设置的方法：

![]( {{site.url}}/asset/software-debugging-kernel-debug-virtual-machine-setting1.png )

![]( {{site.url}}/asset/software-debugging-kernel-debug-virtual-machine-setting2.png )

![]( {{site.url}}/asset/software-debugging-kernel-debug-virtual-machine-setting3.png )

经过以上设置之后，虚拟机中所有对串行端口 1 的读写操作都会被虚拟机管理软件转换为对宿主系统中的命名管道的读写。因此，运行在宿主系统中的调试器便可以通过这个命名管道来与虚拟机中的内核调试引擎痛心了。可以通过以下两种方式来设置调试器，一种是命令行参数：

```
windbg [-y SymPath] -k com:pipe, port=\\.\pipe\PipeName[,resets=0][,reconnect]
```

其中 `PipeName` 应该替换为虚拟机管理软件中设置的名称，即 com_1。

另一种方式是通过图形界面，也就是使用下图中的内核调试属性对话框，选中 Pipe 复选框，然后在 Port 中指定命名管道的全路径，即 `\\.\pipe\com_1`，再选中 Reconnect 复选框。

![]( {{site.url}}/asset/software-debugging-kernel-debug-windbg-setting.png )

使用虚拟机进行内核调试的优点是简单方便，但也有如下缺点：一是难以调试硬件相关的驱动程序；二是涉及到某些底层操作的函数或指令设置断点时，可能导致虚拟机意外重新启动；三是当目标系统中断到调试器时，虚拟机管理软件可能会占用很高的 CPU。