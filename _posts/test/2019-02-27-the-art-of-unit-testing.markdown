---
layout: post
title:  "读书笔记 - 单元测试的艺术"
date:   2019-02-27 21:45:30 +0800
categories: pattern
---

* TOC
{:toc}

- 优秀的单元测试应该有如下特征
    - 自动化的，可重复执行；
    - 容易编写；
    - 运行速度快；
    - 结果稳定；
    - 与环境隔离，没有真实依赖物(当前时间、真实数据之类的)；

- 要理解什么是一个单元，你需要弄清楚自己以前做的是什么类型的测试。你发现以前所作的是集成测试，因为他测试的是一组相互依赖的单元。
- 单元测试要求我们对被测单元有完全的控制，因此被测单元必须与真实依赖物隔离。

- 测试驱动开发
    - 先编写测试，**注意这一步在编码之前**
    - 运行测试(这一步必然失败)
    - 编写代码，使测试通过
    - 以上是一个螺旋式的过程，并不是一次性完成所有测试代码、被测单元的编写后，再去运行测试，而是逐个被测单元依次进行。

- 一个单元测试通常包含三个主要行为
    - Arrange(准备)对象, 创建对象，进行必要的设置；
    - Act(操作)对象；
    - Assert(断言)某件事情是预期的；

- 命名: `[方法名]_[Good/Bad]_[ReturnsTrue/ReturnsFalse]`, 某个方法的正/反检验返回True/False
    - IsInvalidLogFileName_GoodExtension_ReturnsTrue
    - IsInvalidLogFileName_BadExtension_ReturnsFalse

- 简单的测试，测试返回值，测试组件的状态(属性)变化。如果被测单元依赖一些你无法控制的对象(文件系统、时间、数据库、线程等)，这时可以使用*存根(stub)*、*模拟对象(mock)* 等方式来消除这种外部依赖。stub 和 mock 的区别在于你不会对 stub 做断言，具体之后再介绍。

- 如果被测单元直接依赖文件系统这类的对象，那么可以通过重构的方式引入一个文件访问接口作为间接层，让文件访问变成可替换的。然后让我们的 stub 去实现这个接口，从而让原有的工作单元变得更加可控，提高可测试性。
- 接着需要用 stub 来替换原有的实现。也就是把 stub 注入到被测单元中，一般有一下思路:
    - 构造函数注入，就是在构造函数中添加一个新的构造函数，比如支持设置文件访问接口。
    - 通过设置属性来注入 stub

- **交互测试**
- 工作单元可能有三种最终结果：返回值、改变系统状态、调用第三方对象。
- 之前提到的方法中，只涉及到了前两者。基于值的测试，用来验证一个函数返回的值；基于状态的测试，将改变被测试系统的状态，然后验证其可见的行为变化。
- 交互测试用于处理第三种结果，即调用第三方对象。例如调用一个第三方日志软件，这时你需要测试的是对象间的交互本身。

- **模拟对象**
- 模拟对象(Mock)是系统中的伪对象，它可以验证被测试对象是否按预期的方式调用了这个伪对象，因此导致单元测试通过或者失败。通常每个测试最多有一个模拟对象。
- 存根(Stub)和模拟对象(Mock)都是伪对象(Fake Object)，两者的区别在于：存根只是辅助被测代码运行，测试用例针对被测代码进行断言，换句话说，存根不会使测试失败，仅仅是用来模拟各种场景；模拟对象也会与被测代码进行通信，但测试用例需要针对模拟对象进行断言。比如使用一个存根来代替某些配置类的接口，测试用以不会断言存根中的某些配置是否正确，而是断言依赖了这个存根的被测代码是否能够如预期一样工作；比如使用一个模拟对象来代替第三方接口，测试用例需要断言被测代码的某些动作完成后，模拟对象得到了正确的调用(这个过程就是交互测试)。
- 在同一个测试中不能有多个模拟对象，如果这种情况发生的话，意味着你在同时进行多种交互测试，这导致测试过于复杂或者脆弱。


- **隔离框架**
- 手工编写伪对象的代码比较麻烦，有一些隔离框架，可以通过简单的代码构造出伪对象(Stub 和 Mock)。
- 比如 NSubstitude 框架可以通过 `ILogger logger = Substitute.For<ILogger>()` 直接创建出一个实现了 ILogger 接口的伪对象。
- NSubstitude 还支持对伪对象的参数和返回值进行模拟。

- 如果单元测试中有下列任何一种语句，你的测试就包含了不应该有的逻辑:
- switch, if, else 语句
- foreach, for, while 循环
- 包含逻辑的通常会一次测试多个东西，这样的测试可读性比较差，也比较脆弱。
- 通常来说，一个单元测试应该是一系列的方法调用和断言，但是不包含控制流语句，甚至不应将断言语句包含在 try-catch 中。
- 设想一下，如果一个多线程测试或者使用随机数的测试突然失败了，要怎么处理(复杂的逻辑导致测试难以重现)。

- 一次只测试一个关注点，关注点是工作单元的最终结果：一个返回值、系统状态的一个改变、或者对第三方对象的一个调用。

- **避免过度指定**
- 过渡指定的测试对一个具体的被测单元如何实现其内部行为进行了假设，而不是只检查其最终行为的正确性。
- 单元测试中过渡指定主要有以下几种情况：
    - 测试对一个被测试对象的纯内部状态进行了断言；
    - 测试使用多个模拟对象；
    - 测试在需要存根时使用模拟对象；
    - 测试在不必要的情况下指定顺序或使用了精确匹配；
- 单元测试应该测试对象的公共契约和公共功能。