---
layout: post
title:  "《软件调试》 学习 03 断点和单步执行"
date:   2017-03-30 14:10:30 +0800
categories: debugging book-software-debugging
---

* TOC
{:toc}

断点和单步调试是两个经常使用的调试功能，也是调试器的核心功能。本章我们将介绍 IA-32 CPU 是如何支持断点和单步执行功能的。

## 软件断点

x86 系列处理器从其第一代产品 8086 开始就提供了一条专门用来支持调试的指令，即 INT3。简单来说，这条指令的目的就是使 CPU 中断 (break) 到调试器，以供调试者对执行现场进行各种分析。当我们调试程序时，可以在可能有问题的地方插入一条 INT3 指令，使 CPU 执行到这里停下来。这便是软件调试中经常用到的断点 (breakpoint) 功能，因此 INT3 指令又被称为断点指令。

下面的例子直接在代码中插入了一条 INT 3 指令：

```cpp
int main()
{
	_asm INT 3;
	printf ("hello INT 3\n");

    return 0;
}
```

以调试模式执行上述代码，当程序执行到 `_asm INT 3;` 这一行时，会弹出以下对话框：

![]( {{ site.url }}/asset/software-debugging-int-3.png )

点击 break 按钮后，程序便会停在 INT 3 指令所在的位置。由此看来，我们刚刚插入的 INT 3 指令相当于在那里设置了一个断点。实际上，这正是通过注入代码手工设置断点的方法，这种方法在调试某些程序时还非常有用。

### 调试器中设置断点的原理

当我们在调试器 (Visual Studio 等) 中对代码的某一行设置断点时，调试器会先把这里原指令的第一个字节保存起来，然后写入一条 INT 3 指令。因为 INT 3 指令的机器码为 (0xCC)，仅有一个字节，所以设置和取消断点也只需要保存和恢复一个字节。

顺便一提，VC6 会把断点的设置信息(断点所在的文件和行位置)保存在和项目文件相同位置且相同名称的一个 `.opt` 文件中。但要注意的是，这里保存的并不是被替换掉的字节，而是行号信息。因为实际发生字节替换是在启动调试和调试过程中动态进行的。当调试开始时，VC6 会从 `.opt` 文件中取出断点记录，然后根据记录找到内存中对应的指令位置，进行相应的替换和保存。这个过程称为 落实断点 (resolve breakpoint)

### 断点命中

当 CPU 执行到 INT 3 指令时，由于 INT 3 指令的设计目的就是中断到调试器，因此， CPU 执行这条指令的过程也就是产生断点异常 (breakpoint exception, 简称 #BP) 并转去执行异常处理例程的过程。
- CPU 保存当前的执行上下文，包括段寄存器、程序指针寄存器等内容；
- 将注册在中断向量表 (IDT) 中的异常处理例程的入口地址加载到 CS 和 IP(程序指针) 寄存器中；
- CPU 执行异常处理例程，也就是调试器的代码；
- 调试器执行完毕后，执行中断返回指令 (IRET)；
- 恢复原来的上下文，从断点的位置继续执行；

对于 Windows 这样工作在保护模式下的多任务操作系统， INT 3 异常的处理函数是操作系统的内核函数(KiTrap03)。因此 INT 3 会导致 CPU 执行 KiTrap03 例程。因为我们的 INT 3 指令代码是在用户模式下的代码中，因此 CPU 会从用户模式转为内核模式(Ring3 转为 Ring0)。接下来，会经过几个内核函数的分发和处理。因为这个异常是来自用户模式的，而且发起这个异常的程序正处于调试模式(进程的 DebugPort 非 0), 因此内核的分发逻辑会把这个异常通过调试子系统以调试事件的形式分发给用户模式的调试器，对于我们的例子也就是 VC6。分发完毕后，内核的调试子系统会等待调试器 VC6 的回复。收到回复后，调试子系统会层层返回，最后返回到异常处理例程，异常处理例程执行中断返回指令 IRET，使被调试的程序继续执行。

在 VC6 收到调试事件后，它会根据调试事件数据结构中的程序指针得到断点异常的发生位置，然后在自己内部的断点列表中寻找与其匹配的断点记录。如果能找到，则说明这是 “自己” 设置的断点，执行一系列准备动作之后，便允许用户进行交互式调试。

### 恢复执行

当用户结束分析希望恢复被调试程序时，调试器通过调试 API 通知调试子系统，这会导致系统内核的异常分发函数返回到异常处理例程，然后异常处理例程通过 IRET/IRETD 指令触发一个异常返回动作，使 CPU 恢复执行上下文，从发生异常的位置继续执行。注意，这时的程序指针是指向断点所在的那条指令的，此时刚才的断点指令已经被替换成本来的指令，于是程序会从端点位置的原来指令继续执行。

### 特别用途

因为 INT 3 指令的特殊性，所以它有一些特别的用途。我们用 VC6 来进行调试时，常常会发现一块刚分配的内存或者字符串数组里面被填满了 “CC”。如果是在中文环境下，字符 0xCCCC 恰好是中文的 “烫” 字。所以我们会观察到很多的 “烫烫烫。。。”。

0xCC 就是 INT 3 指令的机器码。为了辅助调试，编译器在编译调试版本的时候会用 0xCC 来填充刚刚分配的缓冲区。这样，如果因为缓冲区或堆栈溢出而使得程序指针意外指向了这块区域，那么便会因为 INT 3 指令而立刻中断到调试器。

除了以上用法，编译器还会使用 INT 3 指令来填充函数或代码段末尾的空闲区域，也就是用它来进行内存对齐。

### 断点 API

Windows 提供了 API 可以让你在自己的代码中插入断点。在用户模式下，可以使用 `DebugBreak()` API, 在内核模式下可以使用 `DbgBreakPoint()` 或者 `DbgBreakPointWithStatus()`。

有的时候我们不太好进行 “附加到进程” 的操作，比如在一个 DLL 的入口函数中设置断点，这种情况下要附加到进程会比较困难，因为程序一启动就会加载这个 DLL，这时候再去附加到进程的话，可能断点处的代码已经执行完毕了。或者是在子进程的入口函数处设置断点，子进程被启动后就立刻执行了断点处的代码，时机也比较晚了。这种情况下就可以使用 `DebugBreak()` 函数来设置代码断点。程序执行到此处后必定会中断，你就可以选择合适的调试器来调试了。

### 归纳

因为使用 INT 3 指令产生的断点是依靠插入指令和软件中断机制工作的，因此人们习惯把这类断点称为软件断点，软件断点具有如下局限性：
- 属于代码类断点，即可以让 CPU 执行到代码段内的某个地址时停下来，不适用于数据段和 I/O 空间；
- 对于在 ROM (只读存储器) 中执行的程序（比如 BIOS 或其他固件程序），无法动态增加软件断点。因为目标内存是只读的，无法动态写入断点指令。这时就要使用我们后面要介绍的硬件断点；
- 在中断向量表或中断描述表(IDT) 没有准备好或者遭到破坏的情况下，这类断点是无法或者不能正常工作的，比如系统刚刚启动或 IDT 被病毒篡改后，这时只能使用硬件级的调试工具；

虽然软件断点存在以上不足，但因为它使用方便，而且没有数量限制（硬件断点需要寄存器记录断点地址，有数量限制），所以目前仍然被广泛使用。


## 硬件断点

### 调试寄存器

IA-32 处理器定义了 8 个调试寄存器，分别称为 DR0~DR7。通过这几个寄存器最多可以设置 4 个断点，其基本分工是 DR0~DR3 用来指定断点的内存地址(线性地址) 或 I/O 地址。DR7 用来进一步定义断点的中断条件。DR6 的作用是当调试事件发生时，向调试器 (debugger) 报告事件的详细信息，以供调试器判断发生的是何种事件。

DR7 被称为调试控制寄存器，它分为了几个域，每个域标记了不同的作用：
- 读写域 R/Wn，通过设置这个域，我们可以指定断点的访问类型（又称为访问条件），也就是用何种方式（读写数据、执行代码还是 I/O）访问寄存器 DR0~DR3 中指定的地址时中断。它占了两个 bit 位，因此可以指定四种方式：
	- **读/写 内存中的数据时中断**：这种断点又称为数据访问断点(data access breakpoint)。利用这种断点，可以监控对全局变量或局部变量的读写操作。例如，当进行某些复杂的系统级调试，或者调试多线程程序时，我们不知道是哪个线程或者函数在何时修改了某个变量，这时就可以设置一个数据访问断点。以 WinDbg 为例，命令 `ba w4 00401200` 设置了一个数据访问断点，`w4 00401200` 表示当 CPU 对地址 `00401200` 开始的 4 字节内存区进行写操作时中断。现代调试器还能在此基础上支持复杂的调试断点，比如当某个变量等于某个确定值的时候中断，这其实也可以使用数据断点来实现，其基本思路是设置一个数据断点来监控变量，每次这个变量的值发生变化的时候，CPU 都会通知调试器，调试器就会检查这个值是否满足设定的条件，如果满足，就中断到调试环境；你也可以使用 `ba r4 00401200` 这样的命令，它的效果是当地址 `00401200` 被读取时触发中断；
	- **执行内存中的代码时中断**：这种断点又被称为 代码访问断点(code access breakpoint) 或 指令断点(instruction breakpoint)。这种断点的效果与软件断点类似，只是它无需向代码中插入 INT 3 指令，在某些特殊情况下可以完成软件断点无法完成的效果，例如在 ROM 中设置断点；
	- **读写 I/O 端口时中断**：这种断点又被称为 I/O 访问断点 (Input/Output access breakpoint)。I/O 访问断点对于调试使用输入输出端口的设备驱动程序非常有用。也可以利用 I/O 访问断点来监视对 I/O 空间的非法读写操作，提高系统的安全性。
- 长度域 LENn，在 DR0~DR3 中设置了监视的起始地址，读写域中指定了地址的访问类型，长度域则指定要监视的区域长度。它可以指定 1,2,4,8 字节长的范围；

### 调试异常

IA-32 架构专门分配了两个中断向量来支持软件调试，向量 1 和向量 3。向量 3 用于 INT 3 指令产生的断点异常(breakpoint exception, 简称 #BP)。向量 1 用于其他情况的调试异常，简称为调试异常 (debug exception, 简称 #DB)。上一节介绍的几种硬件断点产生的是调试异常 #DB，所以当硬件断点发生时 CPU 会执行 1 号向量所对应的处理例程。

下表列出了各种导致调试异常的情况以及该情况所产生的异常的类型：

![]( {{ site.url }}/asset/software-debugging-db.png )

### 归纳

因为以上介绍的断点不需要像软件断点那样向代码中插入软件指令，依靠处理器本身的功能便可以实现，所以人们习惯上把这些使用调试寄存器(DR0~DR7)设置的断点叫硬件断点 (hardward breakpoint)，与软件断点区分开来。

硬件断点虽然有很多优点，但是也有不足，最明显的就是数量限制，因为只有 4 个断点地址寄存器，所以每个 IA-32 CPU 最多允许设置 4 个硬件断点。这基本可以满足大多数情况下的调试需要。


## 陷阱标志

上面两节分别介绍了软件断点和硬件断点，这两种方式的基本原理都是使 CPU 执行到指定位置或访问指定位置时中断到调试器。除了断点，还有一类常用的方法也能够使 CPU 中断到调试器，这就是调试陷阱标志(debug trap flag)。

你可以把陷阱标志想象成一面令旗，当有陷阱标志被设置时，CPU 一旦检测到符合陷阱条件的事件发生，就会报告调试异常通知调试器。IA-32 处理器所支持的调试陷阱标志共有以下三种：
- 8086 支持的单步执行标志（标志寄存器 EFLAGS 的 TF 位）；
- 386 引入的任务状态陷阱标志（任务状态段 TSS 的 T 标志）；
- 奔腾 pro 引入的分支到分支单步执行标志 (DebugCtl 寄存器的 BTF 标志)；

### 单步执行标志 TF

在 x86 系列处理器的第一代产品 8086 CPU 的程序状态字 PSW 寄存器中有一个陷阱标志位 (bit 8)，名为 Trap Flag, 简称 TF。当 TF 为 1 时，CPU 每执行完一条指令便会产生一个调试异常 (#DB)，中断到调试异常处理程序。调试器的单步执行功能大多是依靠这一机制来实现的。

之前我们说过，调试异常 #DB 的向量号是 1，因此，设置 TF 位会导致 CPU 没执行一条指令之后，就会转去执行 1 号异常的处理例程。异常发生后，可以通过调试状态寄存器 (DR6) 来识别发生的是何种事件。为了表达方便，我们把因 TF 标志触发的调试异常称为单步异常 (single-step exception)。

在高级语言如 C/C++ 中，一条语句常常对应多条汇编指令，例如 C++ 的一条语句 `i=a+b*c+d/e+f/g+h` 可能对应多达 15 条汇编指令。很容易想到单步执行这条语句有几种可能的方法：第一种是用 TF 标志一步一步来执行每条汇编指令，这种方法意味着会产生 15 条单步异常，调试器会忽略前面的 14 次，把最后一次中断交给用户。第二种方法是在 C++ 语句对应的最后一条汇编指令处动态地插入一条 INT 3 指令，让 CPU 一下子跑到那里，然后单步一次将被替换的那条指令执行完，这种方法需要 CPU 中断到调试器两次。第三种方法是在这条 C++ 语句的下一句的第一条汇编指令处替换一个 INT 3，这样 CPU 中断到调试器一次就可以了。

后两种方法相对于第一种会快许多，但是不幸的是，并不总是能正确地预测出高级语言对应的最后一条指令和下一条语句的开始指令（要往哪里插入 INT 3 指令）。因为存在 `if else` 这样的判断分支。


## 总结

本章介绍了 CPU 对 断点(包括 软件断点 和 硬件断点) 和 单步执行 这两大关键调试功能的支持。




