---
layout: post
title:  "git - merge 原理"
date:   2017-09-22 10:38:30 +0800
categories: other
---

* TOC
{:toc}

# 文件比较

比较两个分支的同一个文件，发现两个分支中的这个文件内容是不一样的，这时候会去找这个文件的 "原件"，也就是寻找两个分支的最近公共祖先，公共祖先 commit 中的文件就是 "原件"。然后拿着原件比较两个分支上的文件，原件和 ours 分支的一样，说明 ours 分支上没改它，是 theirs 分支改了，所以应该采用 theirs 分支的文件；反之如果原件和 theirs 分支的一样，就采用 ours 分支的文件；如果和两个分支的文件都不一样，说明两个分支都改了这个文件，此时 git 会尝试对这个做 auto merge，auto merge 失败就会导致冲突，需要我们手工解决。

文件的新增和删除，跟文件修改的逻辑是一样的。比如说 theirs 分支上新增了一个文件，合并的时候发现公共祖先里没有原件，ours 分支上也没有原件，这个时候 "没有"=="没有"，那就采用 theirs 分支上的这个文件。如果 theirs 分支上删除了一个文件，合并的时候发现原件和 ours 上的一样，说明是 theirs 删了这个文件，那么就采用 theirs 上的修改把文件删掉。

git 能够探测到文件的重命名或者说移动，并且会把文件的重命名历史记录起来。所以文件重命名跟文件修改的逻辑是一样的，也是找到原件，然后对比检查谁进行了移动。
- 在一些特殊的情况下，比如在 ours 分支上重命名 a.txt 到 b.txt，然后大量修改文件内容，git 可能会探测不出来文件被重命名了，而是认为删除了一个文件 a.txt，又新增了另一个文件 b.txt。如果 theirs 分支也做了类似操作，让 git 认为删除了 a.txt，新增了 c.txt。这个时候做合并，git 会认为两个分支都删除了 a.txt，然后各自新增了 b.txt 和 c.txt，最后合并的结果就会是两个文件 b.txt 和 c.txt。这种特殊情况在代码中比较少见，也容易被编译器检查出来，所以问题不大。
- 如果文件很多，git 在探测重命名的时候会警告：warning: inexact rename detection was skipped due to too many files. 。这是因为文件太多超过了 git 探测的限制，这时候可以执行以下两个命令，把限制调高点：
  - git config --global diff.renamelimit 15345
  - git config --global merge.renamelimit 15345

# 文件内容的 auto merge

如果两个分支都修改了同一个文件，git 会尝试做 auto merge，可以把它理解为是一个判断区间是否重复的逻辑，它检查出 ours 分支更改了这个文件的 [m~n] 行，theirs 分支更改了这个文件的 [x-y] 行，然后判断一下这两个区间有没有重合，没重合的话说明改的不是一个地方，就能够自动合并成功，反之就会触发冲突，需要我们手工解决。
- 在一些特殊的情况下，auto merge 可能不会按预期工作，因为 git 不理解代码。比如说 ours 分支上通过注释的方式屏蔽一段 C++ 代码，把 /* 加到 m 行，*/ 加到 n 行，随后在 theirs 分支上修改了 (m~n) 行中间的一段内容。这时候区间不重合，两个分支能够 auto merge 成功，但是实际上不一定满足我们的需要，因为 theirs 分支上的修改也被注释屏蔽了。这种特殊情况在代码里比较少见，所以问题不大。实在不放心可以根据 git merge 输出的日志，检查一下 auto merge 后的文件是否符合预期，git 会输出 Auto-merging <file-path> 这样的日志来表示某个文件触发了 auto merge。

总的来说 git merge 操作很安全，merge 成功的文件都是最新的，冲突的文件没啥办法，只能手工解决。