---
layout: post
title:  "理解 HTTPS 工作原理"
date:   2017-03-24 10:37:30 +0800
categories: web
---

* TOC
{:toc}

## 基础知识

### 对称加密和非对称加密

对称加密很好理解，**通信双方都持有同一个密钥**，这个密钥即用来加密也用来解密，只要密钥不泄露，这个通信过程就是安全的，请看下图：

![]({{ site.url }}/asset/understand-https-symmetric-key-algorithm.png)

对称加密算法在 C/S, B/S 这样的一对多架构下存在着问题:
- 因为客户端和浏览器会分发给用户使用，通过一些技术很容易可以从客户端中获取到这个密钥，只要知道了这个密钥，就可以随意地解密数据了；
- 所有与服务器通信的客户端都是用同样的密钥，只要攻破其中一个客户端，获取到了它的密钥，那么所有其他客户端的密钥也都知道了；

非对称加密则不一样，非对称加密会生成两个密钥 A 和 B. **其中 A 加密的数据，B 可以解密，反过来 B 加密的数据 A 可以解密**。我们经常听到公钥私钥的话题，**其实他俩本质上没有区别, A 或者 B 都可以作为私钥，也都可以做为公钥**。

**所谓私钥和公钥的区别，只是说谁会被秘密地保存起来而已。会被秘密保存的就是私钥，公开出去的就是公钥**。由于客户端容易被攻破，私钥一般都放在服务端。

有了上述的概念后，很容易就能推断出，**对数据进行加密只能使用公钥，对数据进行解密只能使用私钥**。假如你用私钥对数据进行了加密，由于公钥是公开出去的，每个人都可以对这个数据进行解密，那么加密就没意义了。

接着我们可以发现非对称加密在通信上存在一个问题：它只适用于 客户端向服务器 发送数据的情况，也就是客户端用公钥对数据加密，服务器用私钥对数据进行解密。假如反过来执行这个操作，就相当于用私钥对数据进行加密，这种加密就没意义了。

另外需要注意的是，**加密算法只能用来确保数据传输过程中不被其他人解读出来，它并不能防备数据被篡改或伪造**，我们一旦知道了公钥，就能自己加密伪造的数据发送给服务器，服务器使用私钥解密后无法判断这个数据是不是合法的客户端发过来的。

另外，非对称加密还有一个缺点：它的加解密速度相对于对称加密算法而言比较慢，因此不适合用在数据量大的场合。

### 消息摘要

消息摘要（message digest）函数是一种用于判断数据完整性的算法，也称为散列函数或哈希函数，函数返回的值叫散列值，散列值又称为消息摘要或者指纹（fingerprint）

hash 的计算算法有一个特点，假如你对原始数据进行了一小部分的修改(比如在安装包中植入了病毒), 这时候如果再对这个修改后的数据计算 hash, 那么算出的 hash 值(几乎是)必然与原始数据计算出的 hash 值不一样。

**利用摘要算法的这一特点，我们可以校验数据是否被篡改过**。

许多软件在分发的时候除了会提供原始安装包的下载链接，还会提供一个 SHA 值，这个 SHA 值就是软件本体通过 hash 算法算出来的一个数值。例如 eclipse 的下载页面：

![]({{ site.url}}/asset/understand-https-sha-example.png)

如果这个 eclipse 的安装包被篡改过，那么生成的 SHA-512 字符串会与官方给出的不同。

**摘要算法能够保证数据没有被篡改，但它不能保证数据是否被伪造**：在网络通信时，发送方必须把数据本身和它的 hash 值一起发送出去，在发送的过程中有可能被拦截掉，伪造一份新数据，用摘要算法生成一个新的 hash 值，再打包起来发送给接收方。接收方收到之后无法判断数据来源的身份，无法确认这份数据是不是由其他人伪造的。

### 数字签名

数字签名就是为了解决上一节提到的数据来源的身份问题。发送方在发送数据时，会额外附带一份签名，接收方收到这个签名之后，可以通过校验算法来确认这个签名的主人是不是合法的。这一技术是怎么做到的呢？

这一过程利用了之前提到的 非对称加密 算法。我们来看看这个过程：
- 还是有 公钥私钥 两把钥匙，发送方持有一把私钥，接收方持有一把公钥；
- 发送方发送数据的时候，会先对数据进行 hash, 然后用 **私钥对 hash 进行签名(实际上就是加密)**，签名后的结果就被称为数字签名；
- 数字签名会随同数据一起发送给接收方；
- 接收方收到数据和签名之后，利用自己的 **公钥来尝试对签名进行验证(实际上就是解密)**，如果能够解码成功，并且 hash 值与数据能够匹配，说明这份签名是有效的，它确实来自于合法的发送方；

下面是这一过程的图示：

![]({{ site.url }}/asset/understand-https-digital-signature.png)

你可能会奇怪，之前在介绍 非对称加密 的时候不是已经说过了吗？私钥只能解密，公钥只能加密，怎么这里就反过来用了呢？

因为目的不同，在之前的例子里，使用加密算法是为了保证数据不会在传输过程中被其他人看到，而数字签名的目的是为了确认发送方的身份，即使数据被看到也没关系。

也就是说，非对称加密算法有 **两个** 功能：
- 公钥加密的数据只能由私钥解密，只要保护好私钥，数据内容就不会被看到；
- 私钥加密的数据只能由公钥解密，只要保护好私钥，持有者的身份就无法被伪造；

### 公钥证书

公钥证书用来解决公钥分发问题。公钥分发指的是服务器向客户端分发公钥的过程。这里存在一个问题，我们的公钥有可能被中间人掉包：

![]( {{ site.url }}/asset/understand-https-man-in-middle-replace-public-key.png)

仔细看上面的流程，服务端向客户端分发公钥的过程中，中间人拦截了这个公钥，然后把一个假公钥返回给了客户端。客户端之后会用这个假公钥来加密数据，发给中间人，中间人用自己手里的假私钥解密了数据，然后伪造一份假数据，再用真公钥加密后发给服务端。

上述问题利用我们之前提到的技术都不能解决，只要有中间人的存在，客户端和服务器谁都不能信任谁。这种情况下就引入了第三方的认证机构 CA(Certification Authority). 服务器需要把自己的公钥提交给 CA, 由 CA 用自己的私钥将它进行签名(注意是签名不是加密)，生成一个数字证书。在进行通信之前，服务器会把这个证书发给客户端，客户端用 CA 的公钥来校验证书(确认对方的身份确实是 CA)，并得到服务器的公钥，这样一来就保证了公钥分发的安全性。这个对证书的校验过程，实际上利用了之前的数字签名技术(CA 用私钥对证书进行签名，客户端用 CA 的公钥来校验证书)。

注意上述过程还是有个问题的，客户端是怎么拿到 CA 的公钥的呢？如果客户端是从 CA 那里去请求公钥的，那么就又有了之前说的中间人掉包公钥的问题了。

这个问题答案是：**CA 的公钥已经内置在了 操作系统/浏览器中！**

在 Windows 中，你可以从 Internet 选项/内容/证书按钮 这里看到系统中安装的所有证书。我们随便点看一个看看：

![]( {{ site.url }}/asset/understand-https-windows-certificate.png)

可以看到 CA 的公钥是记录在证书里面的。证书里除了公钥还有有效期之类的一系列东西。

这一节的结论是：**公钥证书可以保证公钥分发过程的安全性**。

## HTTPS 实现原理

有了上述技术，我们仍然没能解决通信安全问题，请看下表：

![]( {{ site.url }}/asset/understand-https-example.png)

可以看到，因为只有服务端持有私钥，服务端向客户端发送数据时无法做到防查看(服务端用私钥加密数据没有意义)，客户端向服务端发送数据时无法做到防篡改和防伪造(因为服务端无法确认客户端的身份)。

我们来看看 HTTPS 如何来解决上述问题，下图是 HTTPS 通信建立的过程：

![]( {{ site.url }}/asset/understand-https-handshake.png )

从上图可以看出：
- HTTPS 只在握手阶段使用了 非对称加密，实际进行通信时使用的是 对称加密方式(session key 就是对称加密密钥)；
- 对称加密密钥是通过三个随机数生成的，其中 random1, random2 都是明文传递的(这个时候 Client 还没有获得公钥，加密没有意义)；
- random3 通过公钥加密发送给 Server, 不会被第三方查看到；

然而上图中的流程还是存在一些疑问：

问题一： 是否存在之前提到的中间人伪造服务器身份的问题？
> 不存在，因为服务器会发送证书给客户端。客户端必须在校验通过的情况下才能继续接下来的流程，证书里包含了服务器的公钥，而中间人没有私钥，无法解码通信过程中的数据。

问题二： 是否存在伪造客户端身份的问题？
> 确实是存在的，我们可以伪造一个客户端，自己来生成随机数，从而与服务器进行通信。因此 HTTPS 提供了一个可选项，服务器可以要求客户端也提供证书证明自己的身份。

问题三： 为什么需要 random1 和 random2 ？
> 上图中介绍的是使用 RSA 非对称加密时的握手过程，在这过程里，会有 random3 加密后传给 Server. 但还有另一种加密算法 DH(Diffie-Hellman), 这种加密算法需要双方共享一些信息，之后双方各自利用这些信息在本地生成对话密钥，这种方法可以确保共享 KEY 安全穿越不安全网络。算法的具体原理这里先不介绍了，可以参考相关文档。

我们可以得出 HTTPS 的核心原理：
- 利用数字证书确保服务器身份；
- 利用非对称加密算法，确保客户端可以将随机数安全地传给服务器；
- 利用随机数生成对称密钥，进行实际的通信流程；

## 参考文章：

- [HTTPS连接的前几毫秒发生了什么](http://blog.jobbole.com/48369/)
- [HTTPS 为什么更安全，先看这些](http://blog.jobbole.com/110373/?utm_source=blog.jobbole.com&utm_medium=relatedPosts)
- [图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
- [也许，这样理解HTTPS更容易](https://showme.codes/2017-02-20/understand-https/)
- [Keyless SSL: The Nitty Gritty Technical Details](https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/)




