---
layout: post
title:  "《软件调试》 学习 16 编译和编译期检查"
date:   2017-05-20 16:53:30 +0800
categories: debugging
---

 
 


编译器的调试支持概括为以下几个方面：
- **编译期检查** : 在编译过程中，检查代码中的语法错误；检查可能存在的逻辑错误和设计缺陷，并以编译错误或警告的形式报告出来；
- **运行期检查** : 为了帮助发现程序在运行期间的问题，编译器可以在编译时产生并加入检查功能，包括内存检查、栈检查等；
- **调试符号** : 要支持源代码级调试，调试器必须有足够的信息将 CPU 使用的二进制地址与源程序中的函数名、变量名和源代码行联系起来，起到这种桥梁作用的便是编译器产生的调试符号(Debugging Symbols)。调试符号不仅在源代码级调试中起着不可或缺的作用，在没有源代码的汇编级调试和分析故障转储文件时，也是非常宝贵的资源；
- **内存分配和释放** : 为减少因为内存使用所导致的问题，在编译调试版本时，编译器通常会使用调试版本的内存分配函数，加入自动错误检查和报告功能；
- **异常处理** : Windows 操作系统和 C++ 这样的编程语言都提供了异常处理和保护机制。编译包含异常保护机制的代码需要编译器的支持；
- **映射(Map)文件** : 很多时候，我们可以得到程序崩溃或发生错误的内存地址，这时我们很想知道这个地址属于哪个模块、哪个源文件、甚至哪个函数。调试符号中包含了这些信息，但是他是以二进制形式存储的，不适合人工查阅，映射(MAP)文件以文本文件的形式满足了这一需要；

本章前半部分介绍编译器的基本常识，后半部分将介绍编译错误和编译期检查，最后讨论用于增强编译期检查的标准标注语言 (SAL)。


## 程序的构建过程

下图展现了源代码编译-链接-运行的各个阶段：

![]( {{site.url}}/asset/software-debugging-code-building.png )

### 链接器

链接器的主要职责是将编译器产生的多个目标文件合成为一个可以在目标平台下执行的执行映像。要产生一个 PE 格式的可执行文件，链接器完成的典型任务如下：
- 解决目标文件中的外部符号，包括函数调用和变量引用。如果调用的函数时 Windows API 或其它位于 DLL 模块中的函数，那么需要为这些调用建立输入目录表 (Import Directory Table) 和 输入地址表 (Import Address Table, 简称 IAT)。输入目录表用来描述被引用的文件，IAT 表用来记录或重定位被引用函数的地址。链接器会把输入目录表和 IAT 表放在 PE 文件的输入数据段 (.idata) 中。
- 生成代码段 (.text)，放入已经解决了外部引用的目标代码；
- 生成包含只读数据的数据段 (.data)；
- 生成包含资源数据的资源段 (.rsrc)；
- 生成包含基地址重定位表 (Base Relocation Table) 的 .reloc 段。当链接器产生 PE 文件时，它会假定一个地址作为本模块的基地址，比如 VC6 编译器为 EXE 模块定义的默认基地址是 0x00400000, 当程序运行时，如果加载器将一个模块加载到与默认值不同的基地址，那么这时候就需要基地址重定位表来进行重定位。可以通过链接器的链接选项来指定模块的默认基地址，也可以使用 Visual Studio 所附带的 Rebase 工具来修改 DLL 文件的默认基地址；
- 如果定义了输出函数和变量，则产生包含输出表的 .edata 段。输出表通常出现在 DLL 中，EXE 中一般不包含 .edata 段；
- 生成 PE 文件头，文件头描述了文件的构成和程序的基本信息；

理解链接器和 PE 文件细节的一种极好的方法是使用 PEView 工具，或者使用 SDK 附带的 dumpbin 工具来观察和分析链接器所产生的 PE 文件。下图是使用 PEView 工具分析 EXE 的一个例子：

![]( {{site.url}}/asset/software-debugging-peview.png )

### 加载器

加载器 (Loader) 是操作系统的一个部分，负责将可执行程序从外部存储器 (如硬盘) 加载到内存中，并做好执行准备，包括遍历输入目录表加载依赖模块，遍历 IAT 表绑定动态调用的函数，对基地址发生冲突的模块执行调整工作等。NTDLL 中包含了一系列以 Ldr 开头的函数，用于完成以上任务。


## 编译

尽管编译器的种类很多，实现也千差万别，但是其基本结构通常都是由下图所示的前端和后端两个部分组成。前端负责理解源代码的含义，即分析功能；后端负责产生等价的目标程序，即合成功能：

![]( {{site.url}}/asset/software-debugging-compiler-architecture.png )

前端和后端之间的媒介是中间代码，又称为中间表示 (Intermediate Representation)，即 IR。编译器前端对源程序进行词法分析、语法分析、语义分析，并将其映射到中间表示，后端对中间表示进行优化处理，再将其映射到用机器码表示的目标程序中。而后，链接器再将目标程序链接称为可以执行的执行映像。

### 前端

编译器的前端 (Front End) 负责扫描和分析源程序并产生中间表示 (IR), 它主要完成如下几项任务：
- 词法分析 (Lexical Analysis): 将源代码中的字节流转换为记号流 (token stream)。实现该功能的部分通常称为扫描器 (Scanner)；
- 语法分析 (Syntax Analysis): 对词法分析产生的记号流进行层次分析，根据语法规则 (syntax rules)把单词序列组成语法短语，并表示为语法树(syntax tree)或推导树(derivation tree)的形式；
- 语义分析 (Semantic Analysis): 对语法树中的语句进行语义处理，审查数据类型的正确性，以及运算符是否符合语言规范；
- 中间代码生成: 产生编译器前端和后端交流所使用的中间表示 (IR), 有时也称为中间代码；

### 后端

编译器的后端 (Back End) 负责对前端产生的中间代码进行优化处理，并产生使用目标代码表示的目标程序。优化后的代码仍然用中间代码的形式来表示。目标程序经过链接生成最终的可执行程序。

编译器的前端 - 后端设计使得他们分工明确，前端与被编译的语言有关，不必关心目标平台，而后台与目标平台相关，不必关心源程序语言。


## 编译错误和警告

### 错误 ID 和来源

![]( {{site.url}}/asset/software-debugging-compile-error-source.png )

![]( {{site.url}}/asset/software-debugging-compile-error-range.png )

### 编译警告

编译警告主要来源于编译器前端的语义分析组件。

除了在编译选项中设置警告级别，过滤指定的警告，也可以在源代码中通过编译器的 #pragma warning 指令来控制编译警告：

```cpp
// 禁止 4705 警告
#pragma warning (disable : 4705)

// 将 4705 警告恢复为默认设置
#pragma warning (default : 4705)
```

也可以用 #pragma warning(push) 指令来批量设置警告，之后使用 #pragma warning(pop) 将警告设置恢复到之前的状态：

```cpp
#pragma warning(push)
#pragma warning(disable : 4705, 4706, 4707)
#pragma warning(pop)
```


## 编译期检查

下面介绍两种常见的编译期检查：未初始化的局部变量和类型不匹配，然后讨论另外几种方法：

### 未初始化的局部变量

在函数的入口处，编译器产生的代码会通过调整栈指针来为局部变量分配空间，在函数返回前，编译器产生的代码恢复栈指针的位置，从而释放这些空间。

当编译器编译调试版本时，会自动将所分配的局部变量区域全部初始化为一个固定的值，即 INT3 指令的机器码 0xCC。当编译发布版本时，编译器不会加入这些代码，这样的话，如果程序员自己的代码没有初始化这个局部变量，那么这个变量的值便是分配给它栈空间上的值，这个值可能是前一个函数的局部变量留下的，也可能是栈上的其它值，或者说是随机的。

使用一个随机的值可能会造成隐患，因此使用局部变量前应该进行初始化，如果没有这样做，编译器会发出警告。例如 VC 编译器给出的警告号是 C4700。

### 类型不匹配

编译器在进行语义分析时会检查变量比较、赋值等操作，目的是发现潜在的问题。

例如，当有符号整数和无符号整数比较大小时，VC 编译器会发出如下警告：

```
warning C4018: '>' : signed/unsigned mismatch
```

当赋值语句可能丢失信息时，也会给出警告，比如把一个双精度浮点数赋值给一个单精度变量时，VC 编译器会发出如下警告：

```
warning C4244: '=' : conversion from 'double' to 'float', possible loss of data
```

### 使用编译指令

增加编译期检查的最简单方法是在头文件或者源文件中通过编译器指令加入特别的检查语句。例如 MFC 类库的 AFX.H 头文件一开始便包含了如下检查语句：

```cpp
// afx.h

#ifndef __cplusplus
    #error MFC requires C++ compilation (use a .cpp suffix)
#endif
```

如果一个扩展名为 .c 的源文件包含了 AFX.H 文件，那么便会报以下错误：

```
c:\program files\microsoft visual stuido\vc98\mfc\include\afx.h(15) : fatal error C1189 : #error MFC requires C++ compilation (use a .cpp suffix)
```

### 标注

增加编译期检查的另一种方法是向代码中注入标注信息 (annotation) 为编译器提供帮助，使其可以检查出更多信息。标注的典型应用就是在声明函数原型时使用特定的符号标注函数的参数和返回值。这种方法很早便使用在描述组件接口的 IDL 语言中。VS2005 引入了一种名为标准标注语言 (Standard Annotation Language, 简称 SAL)的标注方法，我们会在下一节介绍。

### 驱动程序静态验证器 (SDV)

增加编译期检查的第四种方法是使用更加复杂的分析和检查算法，通过模式识别、数据挖掘等技术找出满足知识库中所定义规则或与已知错误模式相匹配的 “嫌疑代码”。例如 Windows DDK 中就包含了一个名为 SDV 的工具用于对驱动程序代码进行各种静态检查。

例如如下命令会运行 `IRQL.SDV` 文件中定义的所有规则，以对当前目录的驱动程序进行 IRQL 有关的各种检查：

```
staticdv /config: %WDK%\tools\sdv\samples\rule_sets\wdm\irql.sdv
```


## 标准标注语言

这个就不详细介绍了，有兴趣可以看查看原书来了解。