---
layout: post
title:  "《软件调试》 学习 18 栈和函数调用"
date:   2017-05-23 09:53:30 +0800
categories: debugging
---

* TOC
{:toc}


栈 (stack) 和 函数调用 (function call) 这两项技术是支持软件大厦的基石，很难找到那个软件没有使用 栈 和 函数调用的。

本章先介绍栈的基本概念和栈的创建过程，然后分别介绍栈在函数调用和局部变量分配方面所起的作用，以及栈帧的概念、帧指针省略和栈指针检查。之后将详细介绍调用协定。栈空间的分配和自动增长机制。栈有关的安全问题，以及编译器所提供的检查和保护机制。


## 简介

从数据结构角度看，栈是一种用来存储数据的容器 (container)。放入数据的操作被称为压入，从栈中取出数据的操作被称为弹出。存取数据的一条基本规则是后进先出 (last-in-first-out, LIFO)。

对基于栈的计算机系统而言，栈是存储局部变量和进行函数调用所必不可少的连续内存区域。编译器、操作系统和 CPU 按照规范各尽其责，保证正确合理地使用栈。编译器在编译时会将函数调用和局部变量存取编译为合适的栈操作；操作系统在创建线程时，会为每个线程创建栈，包括分配栈所需的内存空间和初始化有关的数据结构及寄存器；CPU 在执行程序时，会假定 SS 寄存器(Stack Segment 用来描述栈所在的内存段) 和 ESP 寄存器(Extended Stack Pointer 用来记录栈的栈顶地址) 已经指向一个设置好的栈，执行 PUSH 指令时便向 ESP 所指向的内存地址写入数据，然后调整 ESP 的值，使其指向新的栈顶，执行 POP 指令时便从栈顶弹出数据，并会向栈底方向调整 ESP 寄存器的值，保证它们始终指向栈的顶部。当 CPU 使用 CALL 和 RET 这样的函数调用指令时，它也会使用栈。

从线程角度看，栈是每个 Windows 线程的必备设施。在 Windows 系统中，每个线程至少有一个栈，系统线程之外的每个线程有两个栈，一个供该线程在用户态下执行时使用，称为用户态栈；另一个供该线程在内核态下执行时使用，称为内核态栈。在一个运行着多任务的系统中，因为有很多个线程，所以会有多个栈存在。尽管有如此多的栈，但对于 CPU 而言，它只是用当前栈，即 SS 和 ESP 寄存器所指向的栈。当进行不同任务间的切换，以及同一任务内的内核态与用户态之间的切换时，系统会保证 SS 和 ESP 寄存器始终指向合适的栈。

另外值得说明的是，在 x86 系统中，**栈是朝低地址方向生长的**。也就是说，压栈操作会导致 ESP 寄存器(栈指针)的值减小，弹出操作会导致 ESP 值变大。这也意味着，后压入数据的地址总是比先压入数据的地址小。

### 用户态栈和内核态栈

一个线程可能在不同的特权级 (privilege) 下执行，比如用户态的代码调用系统服务时，该线程便会切换到系统模式下执行，所调用的系统服务执行完毕后再切换回用户态执行 (这个过程通常被称为 Context Switch)。如果让用户态的代码和系统服务共用同一个栈，那么必然会存在安全问题。为了保证不同优先级的代码和数据的安全，线程在不同优先级下运行时会使用不同的栈。

x86 系统中有四个特权级，Windows 只使用了其中的两种，所以每个普通的 Win32 线程都有两个栈，一个供线程在内核态下使用，称为内核态栈 (kernel-mode stack)，另一个供线程在用户态下执行时使用，称为用户态栈 (user-mode stack)。对于那些只运行在内核模式下的线程，没有用户态栈，因为它们不需要再用户模式下运行。

CPU 在执行跨越特权级的代码转移时，会自动切换到不同的栈，那么 CPU 是如何找到每个特权级应该使用的栈的呢？答案是每个任务的任务状态段 (TSS) 记录了不同优先级所使用的栈的基本信息。在 TSS 中，偏移 4 到 28 的 24 个字节是用来记录栈的段信息 (SS) 和 栈指针 (ESP) 值的。

在 Windows 为每个线程所维护的基本数据结构中，记录了内核态栈和用户态栈的基本信息。内核态栈记录在 `_KTHREAD` 结构中，用户态栈记录在 `_TEB` 结构中。

每个线程都有一个名为 `_KTHREAD` 的数据结构，该结构位于内核空间中，是 Windows 系统管理、记录线程信息、进行线程调度的重要依据。在这个结构中，有几个字段专门用来记录栈信息：
- StackBase : 内核态栈的基地址；
- StackLimit : 内核态栈的边界；
- LargeStack ：是否已经切换为大内核态栈；
- KernelStack ：内核态栈的栈顶地址，用于保存栈顶 ESP；
- KernelStackResident ：内核态栈是否位于物理内存中；
- InitialStack ：供内核态代码逆向调用用户态代码时记录本来的栈顶位置；
- CallbackStack ：也是在逆向调用时使用；

用户态栈的基本信息记录在线程信息块 `_NT_TIB` 结构中，`NT_TIB` 是线程环境块结构 (TEB) 的一部分，因此可以根据 TEB 的地址来显示 `_NT_TIB` 结构。这里就不单独介绍它了。

内核态栈和用户态栈有一个很明显的区别，用户态栈是可以指定大小的，默认大小为 1MB；而内核态栈完全由系统来控制其大小，其大小因处理器结构不同而不同，但通常在十几 KB 到 几十 KB 之间。考虑到 GUI 线程在调用 GDI 等内核服务时通常需要更大的内核态栈，所以在一个线程被转变为 GUI 线程后，Windows 会为其创建一个较大的可增长的内核态栈来替换掉原来的栈，称为大内核态栈。

### 函数、过程和方法

在软件工程中，函数 (function), 过程 (procedure 或 subroutine) 和 方法 (method) 这三个概念经常被替换使用，因为它们都可以用来指代一段可以被调用的程序代码。

尽管以上三个术语有细微的差异，但本章统一使用函数这一术语来泛指以上三个概念。


## 栈的创建过程

### 内核态栈的创建

PspCreateThread 是 Windows 内核中用于创建线程的一个重要内部函数。无论是创建系统线程 (PsCreateSystemThread) 还是用户线程 (NtCreateThread 服务)，都离不开这个函数。除了创建重要的 ETHREAD 结构， PspCreateThread 的另一个重要任务就是创建内核态栈。

之前我们说过，对于 GUI 线程，Windows 会为其创建的大内核栈。但线程刚刚被创建时，并不是 GUI 线程。Windows 会在创建线程时先统一调用 MmCreateKernelStack 创建一个默认大小的内核态栈。当一个线程别转化为 GUI 线程时，系统的 PsConvertToGuiThread 会给该线程重新创建一个大内核栈，然后使用 KeSwitchKernelStack 切换到新的栈。这个栈是可以改变大小的，当需要时，调用 MmGrowKernelStack 来增长栈，每次增长的幅度至少为一个页面 (4KB)。

内核态的代码可以调用 IoGetStackLimits 函数和 IoGetRemainingStackSize 函数分别得到当前栈的边界和剩余大小。

### 用户态栈的创建

Windows 线程的用户态栈是由 KERNEL32.DLL 中的 BaseCreateStack 函数创建的。

对于进程的初始线程来说，NtCreateProcess 会在调用 NtCreateThread 之前先调用 BaseCreateStack 函数创建栈。

对于初始线程之外的其他线程来说，CreateThread 会调用 CreateRemoteThread 函数，然后 CreateRemoteThread 会在调用内核服务 NtCreateThread 前，先调用 BaseCreateStack 来创建栈。

BaseCreateStack 是一个未公开的函数，其原型大致如下：

```cpp
NTSTATUS BaseCreateStack(
    IN HANDLE hProcess,
    IN DWORD dwCommitStackSize,
    IN DWORD dwReservedStackSize,
    OUT PINITIAL_TEB pInitialTeb)
```

BaseCreateStack 将在 hProcess 参数所指定的进程地址空间中根据 dwCommitStackSize 参数所指定的大小提交一部分作为栈的初始空间。它会把所保留和提交内存区域的参数保存在 pInitialTeb 结构中。这个结构会被传给 NtCreateThread 内核服务，最终被保存到线程的环境块(TEB)中。

dwReservedStackSize 用来指定要创建的栈的保留内存区大小，dwCommitStackSize 用来指定要创建的栈的已经提交的内存区大小。前者指明了为栈保留的最大内存地址空间，后者指明了初始提交的内存空间大小，后者属于前者的一部分。保留空间只是一个地址范围，在使用前还是得进行提交，提交时系统才真的进行内存分配。

进一步来说，保留和提交内存都是通过系统的虚拟内存分配函数来完成的，SDK 中公开了 VirtualAlloc 和 VirtualAllocEx API，事实上它们都是调用内核服务 NtAllocateVirtualMemory:

```cpp
NTSTATUS NtAllocateVirtualMemory(
    IN HANDLE hProcessHandle,
    IN OUT PVOID lpBaseAddress, // 地址指针
    IN ULONG ZeroBits,
    IN OUT PULONG plRegionSize, // 区域大小
    IN ULONG flAllocationTypes, // 要分配的内存类型, MEM_RESERVE 是保留内存，MEM_COMMIT 是提交内存
    IN ULONG flProtect);        // 保护属性，如 PAGE_READONLY, PAGE_READWRITE
```

可以把 BaseCreateStack 创建用户态栈的过程归纳为如下几个重要步骤：
1. 提交空间大小取为内存页大小的倍数，将总保留大小取整为内存分配的最小粒度 (4 字节)；
2. 调用内存分配函数 (NtAllocateVirtualMemory) 保留内存地址空间，内存分配类型为 `MEM_RESERVE`，分配大小为栈空间保留大小；
3. 调用 NtAllocateVirtualMemory 为保留空间的高地址端提交初始栈空间，内存分配类型为 `MEM_COMMIT`，分配的大小为初始提交大小；
4. 如果保留空间大于初始提交空间，则第 3 步会多提交一个页面用作栈保护页面。保护的方法是调用虚拟内存保护函数 `VirtualProtect` 对这个页面设置 `PAGE_GUARD` 属性；

其中第 4 步创建的栈保护页面是实现栈自动增长功能所必须的，我们后续会介绍栈增长机制。

下图展示了刚创建好的栈的示意图，此时栈的基地址为 0x130000, 栈的边界为 0x12f000, 栈中可使用空间为 4KB, 栈的总大小为 1MB。

![]( {{site.url}}/asset/software-debugging-create-stack.png )

地址 0x12f000 和 0x12e000 之间的一个页是保护页，当已经提交的栈空间用完触及到保护页时，系统的栈增长机制会提交更多空间并移动保护页，右侧的图表示栈自动增长一个内存页之后的情形。


## CALL 和 RET 指令

在基于 x86 处理器的系统中，CALL 和 RET 指令是专门用来进行函数调用和返回的。理解这两条指令有助于我们深刻理解函数调用的内部过程和栈的使用方法。

### CALL 指令

CALL 指令是 x86 CPU 中专门用来用作函数调用的命令，简单来说，它的作用就是将当前的函数指针 (EIP 寄存器的值) 保存到栈中 (称为 linking information)，然后转移到 (branch to) 目标操作数所指定的函数 (被调用过程) 继续执行。

根据被调用过程是否位于同一个代码段，CALL 调用被分为进调用 (Near Call) 和远调用 (Far Call) 两种，对于 近调用，CPU 所执行的操作如下：
1. 将 EIP 寄存器的当前值压入栈中供返回时使用；
2. 将被调用过程的偏移 (相当于当前段) 加载到 EIP 寄存器中；
3. 开始执行被调用过程；

对于远调用，CPU 所执行的操作如下：
1. 将 CS 寄存器的当前值压入到栈中供返回时使用；
2. 将 EIP 寄存器的当前值压入到栈中供返回时使用；
3. 将包含被调用过程的代码段的段选择子加载到 CS 寄存器中；
4. 将被调用过程的偏移加载到 EIP 寄存器中；
5. 开始执行被调用过程；

可以看到远调用相对于近调用来说多了一个 CS 寄存器的处理，因为近调用是一个代码段内的调用，因此不需要向栈中压入和切换到代码段，而远调用因为发生在不同代码段间，因此需要保存和切换代码段。

对于 NT 系列的 Windows, 因为使用了平坦内存模型，同一进程内的代码都在一个大的 4GB 段中，因此不需要考虑段的差异，几乎所有时候使用的都是近调用。

### RET 指令

RET 指令用于从被调用过程返回到发起调用的过程。RET 指令可以有一个可选的参数 n, 用于指定 ESP 寄存器要递增的字节数，ESP 递增 n 个字节相当于从栈中弹出 n 个字节，经常用来释放压在栈上的参数。相对于近调用的返回被称为近返回，相对于远调用的返回被称为远返回。

对于近返回，CPU 所执行的操作如下：
1. 将位于栈顶的数据弹出到 EIP 寄存器，这个值应该是发起近调用时 CALL 指令压入的返回地址；
2. 如果 RET 指令中包含参数 n, 那么便将 ESP 寄存器的字节数增加 n ；
3. 继续执行程序指针所指向的指令，通常就是父函数中调用指令的下一条指令；

从以上过程我们可以看到，RET 指令只是单纯地返回到执行这条指令时栈顶所保存的地址，如果栈寄存器 (ESP) 没有指向合适的位置或者栈上的地址被破坏了，那么 RET 指令就会返回到其他地方，这也正是缓冲区溢出攻击的基本原理，我们稍后会详细讨论它。

