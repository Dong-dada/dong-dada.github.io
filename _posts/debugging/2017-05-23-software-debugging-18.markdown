---
layout: post
title:  "《软件调试》 学习 18 栈和函数调用"
date:   2017-05-23 09:53:30 +0800
categories: debugging
---

* TOC
{:toc}


栈 (stack) 和 函数调用 (function call) 这两项技术是支持软件大厦的基石，很难找到那个软件没有使用 栈 和 函数调用的。

本章先介绍栈的基本概念和栈的创建过程，然后分别介绍栈在函数调用和局部变量分配方面所起的作用，以及栈帧的概念、帧指针省略和栈指针检查。之后将详细介绍调用协定。栈空间的分配和自动增长机制。栈有关的安全问题，以及编译器所提供的检查和保护机制。


## 简介

从数据结构角度看，栈是一种用来存储数据的容器 (container)。放入数据的操作被称为压入，从栈中取出数据的操作被称为弹出。存取数据的一条基本规则是后进先出 (last-in-first-out, LIFO)。

对基于栈的计算机系统而言，栈是存储局部变量和进行函数调用所必不可少的连续内存区域。编译器、操作系统和 CPU 按照规范各尽其责，保证正确合理地使用栈。编译器在编译时会将函数调用和局部变量存取编译为合适的栈操作；操作系统在创建线程时，会为每个线程创建栈，包括分配栈所需的内存空间和初始化有关的数据结构及寄存器；CPU 在执行程序时，会假定 SS 寄存器(Stack Segment 用来描述栈所在的内存段) 和 ESP 寄存器(Extended Stack Pointer 用来记录栈的栈顶地址) 已经指向一个设置好的栈，执行 PUSH 指令时便向 ESP 所指向的内存地址写入数据，然后调整 ESP 的值，使其指向新的栈顶，执行 POP 指令时便从栈顶弹出数据，并会向栈底方向调整 ESP 寄存器的值，保证它们始终指向栈的顶部。当 CPU 使用 CALL 和 RET 这样的函数调用指令时，它也会使用栈。

从线程角度看，栈是每个 Windows 线程的必备设施。在 Windows 系统中，每个线程至少有一个栈，系统线程之外的每个线程有两个栈，一个供该线程在用户态下执行时使用，称为用户态栈；另一个供该线程在内核态下执行时使用，称为内核态栈。在一个运行着多任务的系统中，因为有很多个线程，所以会有多个栈存在。尽管有如此多的栈，但对于 CPU 而言，它只是用当前栈，即 SS 和 ESP 寄存器所指向的栈。当进行不同任务间的切换，以及同一任务内的内核态与用户态之间的切换时，系统会保证 SS 和 ESP 寄存器始终指向合适的栈。

另外值得说明的是，在 x86 系统中，**栈是朝低地址方向生长的**。也就是说，压栈操作会导致 ESP 寄存器(栈指针)的值减小，弹出操作会导致 ESP 值变大。这也意味着，后压入数据的地址总是比先压入数据的地址小。

### 用户态栈和内核态栈

一个线程可能在不同的特权级 (privilege) 下执行，比如用户态的代码调用系统服务时，该线程便会切换到系统模式下执行，所调用的系统服务执行完毕后再切换回用户态执行 (这个过程通常被称为 Context Switch)。如果让用户态的代码和系统服务共用同一个栈，那么必然会存在安全问题。为了保证不同优先级的代码和数据的安全，线程在不同优先级下运行时会使用不同的栈。

x86 系统中有四个特权级，Windows 只使用了其中的两种，所以每个普通的 Win32 线程都有两个栈，一个供线程在内核态下使用，称为内核态栈 (kernel-mode stack)，另一个供线程在用户态下执行时使用，称为用户态栈 (user-mode stack)。对于那些只运行在内核模式下的线程，没有用户态栈，因为它们不需要再用户模式下运行。

CPU 在执行跨越特权级的代码转移时，会自动切换到不同的栈，那么 CPU 是如何找到每个特权级应该使用的栈的呢？答案是每个任务的任务状态段 (TSS) 记录了不同优先级所使用的栈的基本信息。在 TSS 中，偏移 4 到 28 的 24 个字节是用来记录栈的段信息 (SS) 和 栈指针 (ESP) 值的。

在 Windows 为每个线程所维护的基本数据结构中，记录了内核态栈和用户态栈的基本信息。内核态栈记录在 `_KTHREAD` 结构中，用户态栈记录在 `_TEB` 结构中。

每个线程都有一个名为 `_KTHREAD` 的数据结构，该结构位于内核空间中，是 Windows 系统管理、记录线程信息、进行线程调度的重要依据。在这个结构中，有几个字段专门用来记录栈信息：
- StackBase : 内核态栈的基地址；
- StackLimit : 内核态栈的边界；
- LargeStack ：是否已经切换为大内核态栈；
- KernelStack ：内核态栈的栈顶地址，用于保存栈顶 ESP；
- KernelStackResident ：内核态栈是否位于物理内存中；
- InitialStack ：供内核态代码逆向调用用户态代码时记录本来的栈顶位置；
- CallbackStack ：也是在逆向调用时使用；

用户态栈的基本信息记录在线程信息块 `_NT_TIB` 结构中，`NT_TIB` 是线程环境块结构 (TEB) 的一部分，因此可以根据 TEB 的地址来显示 `_NT_TIB` 结构。这里就不单独介绍它了。

内核态栈和用户态栈有一个很明显的区别，用户态栈是可以指定大小的，默认大小为 1MB；而内核态栈完全由系统来控制其大小，其大小因处理器结构不同而不同，但通常在十几 KB 到 几十 KB 之间。考虑到 GUI 线程在调用 GDI 等内核服务时通常需要更大的内核态栈，所以在一个线程被转变为 GUI 线程后，Windows 会为其创建一个较大的可增长的内核态栈来替换掉原来的栈，称为大内核态栈。

### 函数、过程和方法

在软件工程中，函数 (function), 过程 (procedure 或 subroutine) 和 方法 (method) 这三个概念经常被替换使用，因为它们都可以用来指代一段可以被调用的程序代码。

尽管以上三个术语有细微的差异，但本章统一使用函数这一术语来泛指以上三个概念。


## 栈的创建过程

### 内核态栈的创建

PspCreateThread 是 Windows 内核中用于创建线程的一个重要内部函数。无论是创建系统线程 (PsCreateSystemThread) 还是用户线程 (NtCreateThread 服务)，都离不开这个函数。除了创建重要的 ETHREAD 结构， PspCreateThread 的另一个重要任务就是创建内核态栈。

之前我们说过，对于 GUI 线程，Windows 会为其创建的大内核栈。但线程刚刚被创建时，并不是 GUI 线程。Windows 会在创建线程时先统一调用 MmCreateKernelStack 创建一个默认大小的内核态栈。当一个线程别转化为 GUI 线程时，系统的 PsConvertToGuiThread 会给该线程重新创建一个大内核栈，然后使用 KeSwitchKernelStack 切换到新的栈。这个栈是可以改变大小的，当需要时，调用 MmGrowKernelStack 来增长栈，每次增长的幅度至少为一个页面 (4KB)。

内核态的代码可以调用 IoGetStackLimits 函数和 IoGetRemainingStackSize 函数分别得到当前栈的边界和剩余大小。

### 用户态栈的创建

Windows 线程的用户态栈是由 KERNEL32.DLL 中的 BaseCreateStack 函数创建的。

对于进程的初始线程来说，NtCreateProcess 会在调用 NtCreateThread 之前先调用 BaseCreateStack 函数创建栈。

对于初始线程之外的其他线程来说，CreateThread 会调用 CreateRemoteThread 函数，然后 CreateRemoteThread 会在调用内核服务 NtCreateThread 前，先调用 BaseCreateStack 来创建栈。

BaseCreateStack 是一个未公开的函数，其原型大致如下：

```cpp
NTSTATUS BaseCreateStack(
    IN HANDLE hProcess,
    IN DWORD dwCommitStackSize,
    IN DWORD dwReservedStackSize,
    OUT PINITIAL_TEB pInitialTeb)
```

BaseCreateStack 将在 hProcess 参数所指定的进程地址空间中根据 dwCommitStackSize 参数所指定的大小提交一部分作为栈的初始空间。它会把所保留和提交内存区域的参数保存在 pInitialTeb 结构中。这个结构会被传给 NtCreateThread 内核服务，最终被保存到线程的环境块(TEB)中。

dwReservedStackSize 用来指定要创建的栈的保留内存区大小，dwCommitStackSize 用来指定要创建的栈的已经提交的内存区大小。前者指明了为栈保留的最大内存地址空间，后者指明了初始提交的内存空间大小，后者属于前者的一部分。保留空间只是一个地址范围，在使用前还是得进行提交，提交时系统才真的进行内存分配。

进一步来说，保留和提交内存都是通过系统的虚拟内存分配函数来完成的，SDK 中公开了 VirtualAlloc 和 VirtualAllocEx API，事实上它们都是调用内核服务 NtAllocateVirtualMemory:

```cpp
NTSTATUS NtAllocateVirtualMemory(
    IN HANDLE hProcessHandle,
    IN OUT PVOID lpBaseAddress, // 地址指针
    IN ULONG ZeroBits,
    IN OUT PULONG plRegionSize, // 区域大小
    IN ULONG flAllocationTypes, // 要分配的内存类型, MEM_RESERVE 是保留内存，MEM_COMMIT 是提交内存
    IN ULONG flProtect);        // 保护属性，如 PAGE_READONLY, PAGE_READWRITE
```

可以把 BaseCreateStack 创建用户态栈的过程归纳为如下几个重要步骤：
1. 提交空间大小取为内存页大小的倍数，将总保留大小取整为内存分配的最小粒度 (4 字节)；
2. 调用内存分配函数 (NtAllocateVirtualMemory) 保留内存地址空间，内存分配类型为 `MEM_RESERVE`，分配大小为栈空间保留大小；
3. 调用 NtAllocateVirtualMemory 为保留空间的高地址端提交初始栈空间，内存分配类型为 `MEM_COMMIT`，分配的大小为初始提交大小；
4. 如果保留空间大于初始提交空间，则第 3 步会多提交一个页面用作栈保护页面。保护的方法是调用虚拟内存保护函数 `VirtualProtect` 对这个页面设置 `PAGE_GUARD` 属性；

其中第 4 步创建的栈保护页面是实现栈自动增长功能所必须的，我们后续会介绍栈增长机制。

下图展示了刚创建好的栈的示意图，此时栈的基地址为 0x130000, 栈的边界为 0x12f000, 栈中可使用空间为 4KB, 栈的总大小为 1MB。

![]( {{site.url}}/asset/software-debugging-create-stack.png )

地址 0x12f000 和 0x12e000 之间的一个页是保护页，当已经提交的栈空间用完触及到保护页时，系统的栈增长机制会提交更多空间并移动保护页，右侧的图表示栈自动增长一个内存页之后的情形。


## CALL 和 RET 指令

在基于 x86 处理器的系统中，CALL 和 RET 指令是专门用来进行函数调用和返回的。理解这两条指令有助于我们深刻理解函数调用的内部过程和栈的使用方法。

### CALL 指令

CALL 指令是 x86 CPU 中专门用来用作函数调用的命令，简单来说，它的作用就是将当前的函数指针 (EIP 寄存器的值) 保存到栈中 (称为 linking information)，然后转移到 (branch to) 目标操作数所指定的函数 (被调用过程) 继续执行。

根据被调用过程是否位于同一个代码段，CALL 调用被分为进调用 (Near Call) 和远调用 (Far Call) 两种，对于 近调用，CPU 所执行的操作如下：
1. 将 EIP 寄存器的当前值压入栈中供返回时使用；
2. 将被调用过程的偏移 (相当于当前段) 加载到 EIP 寄存器中；
3. 开始执行被调用过程；

对于远调用，CPU 所执行的操作如下：
1. 将 CS 寄存器的当前值压入到栈中供返回时使用；
2. 将 EIP 寄存器的当前值压入到栈中供返回时使用；
3. 将包含被调用过程的代码段的段选择子加载到 CS 寄存器中；
4. 将被调用过程的偏移加载到 EIP 寄存器中；
5. 开始执行被调用过程；

可以看到远调用相对于近调用来说多了一个 CS 寄存器的处理，因为近调用是一个代码段内的调用，因此不需要向栈中压入和切换到代码段，而远调用因为发生在不同代码段间，因此需要保存和切换代码段。

对于 NT 系列的 Windows, 因为使用了平坦内存模型，同一进程内的代码都在一个大的 4GB 段中，因此不需要考虑段的差异，几乎所有时候使用的都是近调用。

### RET 指令

RET 指令用于从被调用过程返回到发起调用的过程。RET 指令可以有一个可选的参数 n, 用于指定 ESP 寄存器要递增的字节数，ESP 递增 n 个字节相当于从栈中弹出 n 个字节，经常用来释放压在栈上的参数。相对于近调用的返回被称为近返回，相对于远调用的返回被称为远返回。

对于近返回，CPU 所执行的操作如下：
1. 将位于栈顶的数据弹出到 EIP 寄存器，这个值应该是发起近调用时 CALL 指令压入的返回地址；
2. 如果 RET 指令中包含参数 n, 那么便将 ESP 寄存器的字节数增加 n ；
3. 继续执行程序指针所指向的指令，通常就是父函数中调用指令的下一条指令；

从以上过程我们可以看到，RET 指令只是单纯地返回到执行这条指令时栈顶所保存的地址，如果栈寄存器 (ESP) 没有指向合适的位置或者栈上的地址被破坏了，那么 RET 指令就会返回到其他地方，这也正是缓冲区溢出攻击的基本原理，我们稍后会详细讨论它。


## 局部变量和栈帧

编译器在为局部变量分配空间时通常有两种做法：使用寄存器和使用栈。我们把分配在寄存器中的局部变量称为寄存器变量，把分配在栈上的局部变量称为栈变量。

从性能上来看使用寄存器来分配局部变量是最好的。但寄存器的空间和数量都是有限的，所以编译器在优化的时候会尽量把频繁使用的变量放到寄存器中。

对于调试版本来说，编译器会在栈上分配所有局部变量。本节讨论的重点也是栈变量。

### 局部变量的分配和释放

简单来说，局部变量的分配和释放是由编译器插入的代码通过调整栈指针 (Stack Pointer) 的位置来完成的。

编译器在编译的时候，会计算当前代码块 (如函数中) 所声明的所有局部变量所需要的空间，并将其按照内存对齐规则取值为满足对其要求的最接近整数值。例如在 32 位系统中，内存分配是按照 4 字节对其的，这意味着不满 4 字节的空间分配会按照 4 字节来分配。距离来说，如果某个 ANSI 类型的字符数组长度是 13, 那么实际上会分配 16 个字节的栈空间给它。

计算好空间之后，编译器会插入适当的指令来调整栈指针，为局部变量分配出空间来。对于 x86 系统而言，栈指针保存在 ESP 寄存器中，所以调整栈指针实际上也是调整 ESP 寄存器的值。

编译器有几种方法来调整 ESP 寄存器的值，一种方法是对其进行加减运算：

```asm
sub esp, 10h        ; 将 ESP 寄存器的值减去 16, 也就是增加 16 字节的栈空间；
add esp, 10h        ; 将 ESP 寄存器的值加上 16, 也就是减小 16 字节的栈空间；
add esp, 0FFFFFCC   ; 加上一个负数 (-34)，相当于减去 34；
```

另一种方式是使用 PUSH 和 POP 指令，这两个指令的执行速度比 sub 和 add 要快，如果只需要一两个 PUSH 和 POP 就能干的事儿，编译器会尽量使用它，而不是使用 add 和 sub. 

另外注意到栈是向低地址方向生长的，所以分配空间的时候，是使 ESP 寄存器递减，释放空间是使 ESP 寄存器递增。

下面看个例子：

```c
int FuncA()
{
    int l, m, n;
    char sz[] = "Advanced SW Debugging";
    l = sz[0];
    m = sz[4];
    n = sz[8];
    return l*m*n;
}
```

函数 FuncA 中定义了 4 个局部变量，其中 3 个整形变量占 12 个字节，一个字符串变量占 22 个字节。我们来看看它的反汇编代码 (release 版本)：

![]( {{site.url}}/asset/software-debugging-local-variable-stack.png )

可以看到上述代码的第二行，`sub esp 0x18` 这条指令，分配了 24 个字节的栈空间。这个空间是给字符串变量分配的，它本来是 22 字节，因为字节对齐而被扩展为 24 个字节。这里没有为 3 个整型变量分配栈空间，因为是 release 版本，编译器会尽可能将局部变量存储到寄存器上。

接下来 4 到 5 行把 esi 和 edi 寄存器中的内容保存到了栈上，因为接下来将要用这两个寄存器来初始化字符串变量。

第 6 行把字符串常量 `"Advanced SW Debugging"` 的地址赋值给了 esi 寄存器。

第 7 行把栈上 sz 变量的地址赋值给了 edi 寄存器，因为第 4 行和第 5 行压入了两个 4 字节的值到栈上，所以现在 sz 的地址是栈顶地址加 8, 也就是 `esp + 0x8`；

第 8 行是个循环指令，循环的次数记录在 ecx 寄存器中，之前第 3 行已经把 ecx 设定为 5, 所以会循环 5 次，每次循环都会把 4 个字节的内容拷贝到 sz 变量中，也就是会拷贝 20 个字节；

第 9 行拷贝了 2 个字节的内容到 sz 变量中，补足了 sz 变量的长度 (22)；

第 10 ~ 12 行，是为 l, m, n 这三个局部变量赋值的过程，将 sz 变量的第 0, 4, 8 位值赋值给这三个变量，这三个变量依次存储在 EDX, ECX, EAX 这三个寄存器中；

第 13 行和 第 15 行执行了乘法运算，运算结果最终保存在了 EAX 寄存器中；

第 14 行和 第 16 行将栈中的 edi 和 esi 寄存器信息恢复了回去；

第 17 行的 `add esp 0x18` 用来释放栈空间，对应于一开始的 `sub esp 0x18` 指令，可以看到栈是平衡的；

第 18 行调用 ret 指令返回到调用方，这时候栈顶存放的是调用 FuncA 时的 EIP 的信息，ret 会根据这个地址来返回到原来的调用处，然后弹出这个地址信息，将栈顶恢复成原调用方的情况；

### EBP 寄存器和栈帧

对于分配在栈上的局部变量，编译器是如何来引用它们的呢？对于前面 FuncA 中的 sz 变量，第 7 行是通过 `esp + 0x8` 来引用它的，也就是以 ESP 寄存器作为参照物来引用局部变量 sz. 这种做法的缺点是不稳定，ESP 的值可能会发生变化，这时候对 sz 的引用也会发生变化。例如下面的 FuncB 函数：

```c
void FuncB(char* szPara)
{
    char szTemp[5];
    strncpy(szTemp, szPara, sizeof(szTemp) - 1);
    printf("%s; Len = %d.\n", szTemp, strlen(szTemp));
}
```

我们来看看它的反汇编代码 (release) 版本：

![]( {{site.url}}/asset/software-debugging-local-variable-stack-example2.png )

可以看到上述代码中，有三个地方都引用了 szTemp, 这三次引用分别使用的是 esp, esp+0x10, esp+0x4, 之所以会这样是因为在这三次引用中间存在多条 push, pop 指令，导致 esp 的值一直在变化。

如果想通过反汇编来调试上述代码，我们不得不时时注意 esp 的变化，才能知道当前表示 sz 的值是多少，这太麻烦了。

为了解决上述问题，x86 CPU 设计了 EBP 寄存器，它的全称是 Extended Base Pointer, 即扩展的基址指针。它记录了函数自己栈空间的基准地址，换句话说，就是刚刚进入函数时的栈顶地址。可以用它来引用局部变量和参数，在同一函数内，EBP 寄存器的值是保持不变的，这样函数内的局部变量便有了一个固定的参照物。

通常，一个函数在入口处将当时的 EBP 值压入堆栈，然后把 ESP 值(栈顶)赋给 EBP，这样 EBP 中的地址就是进入本函数时的栈顶地址，这一地址上面(递减方向)接下来的空间就是该函数将要使用的栈空间，它的下面(递增方向)就是父函数的栈空间。这样设置了 EBP 之后，就可以通过 EBP + n 的方式来引用父函数栈空间中的内容，使用 EBP - n 的方式来引用本函数栈空间中的内容。

因为在将栈顶地址 ESP 的值赋值给 EBP 寄存器之前，会先把旧的 EBP 值保存在栈中，所以 EBP 所指向的栈单元中保存的是前一个 EBP 寄存器的值，通常也就是父函数的 EBP 的值。类似的，复函数中 EBP 的值指向的是更上一层函数的 EBP 值，依次类推，直到当前线程的最顶层函数。这也正是栈回溯的基本原理。

现在看个例子，把之前的 FuncB 改名为 FuncC, 并且在函数前面加上 `#pragma optimize("", off)`, 在后面加上 `#pragma optimize("", on)`, 从而屏蔽优化。以下是它的反汇编代码：

![]( {{site.url}}/asset/software-debugging-local-variable-stack-ebp.png )

可以看到上述例子中，每次对 szTemp 变量的引用，其地址都是 `[ebp-0x8]`, 而不是像之前 FuncB 那样每次是不同的值。

下图画出了当 CPU 执行 FuncC 函数时栈的状态：

![]( {{site.url}}/asset/software-debugging-local-variable-stack-funcc.png )

从上面的分析我们可以看到，尽管栈中的数据是连续存储的，好像所有数据都混作一团，但事实上，它们是按照函数调用关系依次存放的，而且这种关系非常严格。为了更好地描述和指代栈中的数据，我们把每个函数在栈中所使用的区域成为一个栈帧(Stack Frame)。在上图中，共有 4 个栈帧，分别属于 Func, main, mainCRTStartup, BaseProcessStart 函数。

关于栈帧还有以下几点值得说明：
1. 在一个栈中，依据函数调用关系，发起调用的函数 (Caller) 的栈帧在下面(高地址方向), 被调用的栈帧在上面；
2. 每发生一次函数调用，便产生一个新的栈帧，当一个函数返回时，这个函数所对应的栈帧被消除 (eliminated)；
3. 线程正在执行的那个函数所对应的栈帧位于栈的最顶部，它也是栈内仍然有效的最年轻(建立时间最晚)栈帧；

我们可以归纳出建立栈帧的典型指令序列：

![]( {{site.url}}/asset/software-debugging-stack-frame-begin.png )

在函数的出口，通常有对应的消除栈帧的指令序列：

![]( {{site.url}}/asset/software-debugging-stack-frame-end.png )

### 帧指针和栈帧的遍历

指向每个栈帧的指针被称为帧指针 (Frame Pointer), 因为在 x86 系统中通常使用 EBP 寄存器作为帧指针使用，所以经常会使用 ChildEBP 或 EBP 来指代帧指针。

当一个函数建立一个新的栈帧时，它会将当时的 EPB 值压入栈保存起来，然后立刻把当时的栈指针赋值给 EBP 寄存器。这样 EBP 的值便是新栈帧的基础地址，而这个地址在栈中的值便是 EBP 的以前值，也就是前一个栈帧的基础地址。以此类推，我们可以遍历整个栈中的所有栈帧，这也正是调试器的 Calling Stack 功能 (显示函数调用序列) 的基本原理。

这样从当前栈帧层层追溯而得到函数调用记录的过程被称为栈回溯 (Stack Backtrace)。栈回溯信息对软件调试有着非常重要的意义，比如可以通过参数值核对参数的正确性，根据帧指针观察局部变量，根据程序指针信息了解函数调用关系。因此，大多数调试器都提供了显示栈回溯信息的功能。比如 WinDBG 提供了一系列以 k 开头的命令 (k, kb, kd, kp, kP, kv) 来显示各种格式的栈回溯信息。