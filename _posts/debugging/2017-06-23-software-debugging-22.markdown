---
layout: post
title:  "《软件调试》 学习 22 WinDBG 用法详解"
date:   2017-06-23 09:48:30 +0800
categories: debugging
---

* TOC
{:toc}


## 工作空间

WinDBG 使用工作空间 (Workspace) 来描述和存储调试项目的属性、参数以及调试器设置等信息，其功能相当于 IDE 中的项目文件。

WinDBG 定义了两种工作空间，一种称为默认的工作空间 (Default Workspace), 另一种称为命名的工作空间 (Named Workspace). 当没有明确使用某个命名的工作空间时，WinDBG 总是使用默认的工作空间。

所谓的命名工作空间，需要在打开 WinDBG 调试程序时，在菜单项中选择 Save workspace As... 选项，然后自己为当前的工作空间进行命名保存：

![]( {{site.url}}/asset/software-debugging-windbg-save-workspace.png )

下次再调试时，可以通过菜单项中的 Open workspace 来打开之前保存的工作空间：

![]( {{site.url}}/asset/software-debugging-windbg-open-workspace.png )


## 命令概览

WinDBG 有三类命令：标准命令、元命令、扩展命令。

### 标准命令

标准命令用来提供适用于所有调试目标的基本调试功能，执行这些命令时不需要加载任何扩展模块。

WinDBG 共实现了 130 多条标准指令，分为 60 多个系列。为了便于记忆，可以归纳为如下 18 个子类：

- 控制调试目标执行，包括恢复运行的 g 系列命令、跟踪执行的 t 系列命令、单步执行的 p 系列命令、追踪监视的 wt 命令；
- 观察和修改通用寄存器的 r 命令，读写 MSR 寄存器的 rdmsr 和 wrmsr, 设置寄存器显示掩码的 rm 命令；
- 读写 IO 端口的 ib/iw/id 和 ob/ow/od 命令；
- 观察、编辑和搜索内存数据的 d 系列命令、e 系列命令和 s 命令；
- 观察栈的 k 系列命令；
- 设置和维护断点的 bp(软件断点), ba(硬件断点) 和管理断点的 bl(列出所有断点), bc/bd/be(清除、禁止和重启断点)命令；
- 显示和控制线程的 ~ 命令；
- 显示进程的 I 命令；
- 评估表达式的 ? 命令和评估 C++ 表达式的 ?? 命令；
- 用于汇编的 a 命令和用于反汇编的 u 命令；
- 用于显示段选择子的 dg 命令；
- 执行命令文件的 $ 命令；
- 设置调试事件处理方式的 sx 系列命令，启用与禁止静默模式的 sq 命令，设置内核选项的 so 命令，设置符号后缀的 ss 命令；
- 显示调试器和调试目标版本的 version 命令，显示调试目标所在系统信息的 vertarget 命令；
- 检查符号的 x 命令；
- 控制和显示源程序的 ls 系列命令；
- 加载调试符号的 ld 命令，搜索相邻符号的 ln 命令和显示模块列表的 lm 命令；
- 结束调试会话的 q 命令，包括用于远程调试的 qq 命令，结束调试会话并分离调试目标的 qd 命令；

在命令编辑框中输入一个 ? 可以显示出主要的标准命令和每个命令的简单介绍。

### 元命令

元命令 (Meta-Command) 用来提供标准命令没有提供的常用调试功能，与标准命令一样，元命令也是内建在调试器引擎或者 WinDBG 程序文件中的。

所有元命令都是以一个点 (.) 开始，所以元命令页称为点命令 (Dot Command)。

元命令可以分为如下几类：
- 显示和设置调试会话和调试器选项，比如用于符号选项的 .symopt, 用于符号路径的 .sympath 和 .symfix, 用于源程序文件的 .srcpath, .srcnoise 和 .srcfix, 用于扩展命令模块路径的 .extpath, 用于匹配扩展命令的 .extmatch, 用于可执行文件的 .exepath, 设置反汇编选项的 .asm, 控制表达式评估器的 .expr 命令；
- 控制调试会话或调试目标。如重新开始的 .restart 命令。放弃用户态调试目标的 .abandon。创建新进程的 .create 命令和附着在存在进程的 .attach 命令。打开转储文件的 .opendump。分离调试目标的 .detach。用于杀掉进程的 .kill；
- 管理扩展命令模块。如加载模块的 .load 命令。卸载模块的 .unloead 命令和 .unloadall 命令。显示已加载模块的 .chain 命令；
- 管理调试器日志文件。如 .logfile(显示信息), logopen(打开文件), .logappend(追加) 和 .logclose (关闭文件)；
- 远程调试命令；
- 控制调试器。如让调试器睡眠一段时间的 .sleep 命令。唤醒调试器的 .wake 命令。启动另一个调试器来调试当前调试器的 .dbgdgb 命令；
- 编写命令程序。包括一系列类似于C语言关键字的命令。如 .if、.else、.elseif、.foreach、.do、.while、.continue、.catch、.break、.leave等；
- 显示或转储调试目标数据。如产生转储文件的 .dump 命令。将原始数据写到文件的 .writemem 命令。显示调试会话时间的 .time 命令。显示线程时间的 .ttime 命令。显示任务列表的 .tlist 命令。以不同格式显示数字的 .format 命令；

输入 .help 命令可以列出所有元命令和每个元命令的简单说明。

### 扩展命令

扩展命令 (Extension Command) 用于实现针对特定调试目标的调试功能。与标准命令和元命令是内建在 WinDBG 程序文件中不同，扩展命令是实现在动态加载的扩展模块中的。

利用 WinDBG 的 SDK, 用户可以自己编写扩展模块和扩展命令。WinDBG 的程序包中包含了常用的扩展命令模块，下表列出了 WINEXT 和 WINXP 目录中的所有扩展命令模块：

![]( {{site.url}}/asset/software-debugging-windbg-ext-command.png )

执行扩展命令时，应该以叹号 (!) 开始，叹号在英文中被称为 bang, 因此扩展命令也被称为 Bang Command, 执行扩展命令的格式是：

```
![扩展模块名].<扩展命令名>[参数]
```


## 用户界面

以下是 WinDBG 的工作窗口：

![]( {{site.url}}/asset/software-debugging-windbg-work-viewer.png )

可以在菜单中选择显示这些窗口，保存工作空间时，窗口布局也会被保存。

### 命令窗口和命令提示符

命令窗口是用户与 WinDBG 交互的最主要接口，它分为信息显示区和命令横条两部分，命令横条中又包含了命令提示符和命令编辑框：

![]( {{site.url}}/asset/software-debugging-windbg-command-window.png )


## 输入和执行命令

### 要点

- 可以在同一行输入多条命令，用分号 (;) 作为分隔符；
- 直接按回车键可以重复上一条命令；
- 按上下方向键可以浏览和选择以前输入过的命令；
- 输入元命令时应该以点 (.) 开头，输入扩展命令时以叹号 (!) 开头；
- 可以使用 Ctrl+break 来终止一个长时间未完成的命令，如果使用的是 KD 或 CDB, 那么应该使用 Ctrl+C；
- 使用 Ctrl+Alt+V 可以开启 WinDBG 的详细输出模式，观察到更多调试信息，再按一次恢复原来的模式；
- 输入 .hh 加上希望了解的命令，可以随时打开帮助文档进行查看；

### 表达式

这一节的内容我不太懂，基本意思是说 WinDBG 里可以输入一些表达式，这些表达式可以在被调试进程的上下文中执行，比如 `?? const_cast<unsigned int>(0xffffffee)` 表示在当前进程上下文中执行一个 C++ 语句。

这个表达式还可以跟 bu 等命令结合起来用，比如：

```
bp `ctest!main.cpp:100`
```

表示在 CTest 模块的 main.cpp 文件的第 100 行加一个断点。

其他的不太了解了，需要用到的话可以参考相关文章。

### 伪寄存器

为了可以方便地引用被调试程序中的数据和寄存器，WinDBG 定义了一系列伪寄存器：

![]( {{site.url}}/asset/software-debugging-windbg-pseudo-register.png )

### 进程和线程限定符

在很多命令前可以加上进程和线程限定符，用来指定这些命令所适用的进程和线程：

![]( {{site.url}}/asset/software-debugging-windbg-process-thread-identifier.png )

例如，可以使用如下命令来显示 0 号线程的寄存器和栈回溯，即使当前是在 1 号线程：

```
0:001> ~0r; ~0k;
```

### 记录到文件

WinDBG 可以把输入的命令和命令的执行结果输出到文件中，可以使用 Edit 菜单中的 Open/Close Log 来启用和关闭日志文件，也可以使用 .logopen, .logclose, .logfile 这几个命令来打开、关闭、显示日志文件；


## 建立调试会话

### 附加到已经运行的进程

有以下几种方法可以把调试器附加到已经运行的进程
- 使用 WinDBG File 菜单中的 Attach to a Process 命令，或者按下 F6 热键，来选择要附加的进程；
- 将 WinDBG 设置为 JIT 调试器 (执行 WinDBG -I), 这样当程序崩溃时，在应用程序错误对话框中选择 Debug, 系统便会启动 WinDBG 并将其附加到这个进程；
- 启动 WinDBG 时通过 -p 开关指定要附加的进程；
- 启动 WinDBG 时通过 -pn 开关指定要附加的进程名；

### 创建并调试新的进程

有以下几种方法可以使用调试器启动一个新的进程：
- 使用 WinDBG File 菜单中的 Open Executable 命令，或者按下 Ctrl+E 热键，来选择要打开的可执行文件；
- 启动 WinDBG 时将要调试的程序文件作为命令行参数传给 WinDBG；
- 在注册表的 `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution` 键下，创建一个以要调试程序文件名命名的子键，然后在这个子键下创建一个名为 Debugger 的 `REG_SZ` 类型的键，取值为 WinDBG 的完整路径，这样当改程序启动时，操作系统就会先启动 WinDBG, 并把被调试程序的路径传给它；

无论使用上述哪种方法，被调试进程都是作为 WinDBG 的子进程创建的。

### 非侵入式调试

非侵入调试是调试用户态进程的一种特殊方式，使用这种方式，WinDBG 与目标进程没有真正建立调试与被调试关系，不能接收到任何调试事件，只能够执行观察目标进程的各种命令，不能控制调试目标，包括单步调试、继续执行等，都是不可以的。

非侵入式调试只适用于附加到进程的方式，只要在附加到进程时选择 Noninvasive 复选框，就会使用非侵入式调试的方式。

因为没有真正建立调试关系，所以使用非侵入式调试时，不会影响其他调试器再附加到这个进程进行普通调试。

### 调试内核目标

与用户态调试相比，建立双机内核调试要复杂一些，具体可以参考原文。

### 调试转储文件

WinDBG 支持以下三种方式来打开转储文件：
- 运行 WinDBG, 接着在 File 菜单中选择 Open Crash Dump, 然后选择要打开的文件；
- 使用命令行方式，通过 -z 开关指定要打开的转储文件；
- 在当前调试会话中执行 .opendump 命令，用于调试多个目标的情况；


## 终止调试会话

### 停止调试

当 WinDBG 处于命令模式时，在 WinDBG 的 Debug 下拉菜单中选择 Stop Debugging 可以终止当前的调试会话，使调试器恢复到赋闲 (Dormant) 状态。

### 分离调试目标

可以使用分离调试目标功能来结束调试器与调试目标的调试关系。操作方式有两种，一种是使用 Debug 菜单中的 Detach Debuggee 命令，另一种是输入 .detach 命令。

在调试用户态的活动目标时，这一命令执行后，目标进程会继续执行，而不是像 Stop Debugging 那样终止目标进程。

### 抛弃被调试进程

在分离调试目标后，目标进程会退化为一个普通进程。如果希望让其保持被调试状态，可以使用 .abandon 命令来抛弃当前的被调试进程。

被调试进程被抛弃后仍然处于挂起状态，这时候可以使用另一个调试器附加到被调试进程。

### 杀死被调试进程

在内核调试时，可以使用 .kill 命令杀死指定的进程，在用户态调试时，可以使用这个命令杀死当前进程。

### 调试器终止或僵死

如果直接关闭调试器程序，那么它所建立的调试会话也会终止，调试会话中如果包含活动的目标调试进程，那么该进程也会被终止。

如果调试器因为某种原因僵死，但是调试任务尚未完成，此时可以使用 -pe 开关来启动另一个调试器附加到被调试进程，然后再终止僵死的调试器进程实例；

### 重新开始调试

Debug 菜单中的 Restart 菜单项和 .restart 命令可以用来重新开始当前的调试会话。

如果是调试器创建的目标进程，那么目标进程会被关闭然后重新运行。


## 理解上下文

Windows 是个典型的多任务操作系统，在一个系统中可以有多个登录回话 (Login Session), 每个会话中可以运行多个进程，每个进程又可以运行多个线程。在调试这样的系统时，大多数命令操作或执行结果都是基于一定的上下文的 (Context)。根据 Windows 操作系统的特征，WinDBG 定义了如下几种上下文：会话上下文、进程上下文、寄存器上下文和局部变量上下文。

### 登录上下文

Windows 支持同时有多个登录回话，每个会话有自己的输入输出设备和桌面。在典型的 Windows XP 系统中通常只有一个会话，当从另一个机器使用远程桌面登录到这个系统后，系统中便有了两个会话。

Vista 引入了会话隔离 (Session Isolation) 技术让所有系统服务运行在会话 0 以增强系统服务的安全性，所以典型的 Vista 系统至少有两个会话。

所谓登录会话上下文 (Login Session Context) 就是当前操作所基于的登录会话语境。例如，对于会话 A 的所有进程来说，会话 A 的状态和属性便是它们的会话上下文。

使用 !session 扩展命令可以显示或切换登录回话上下文。在内核调试时，可以使用 !session 命令观察和设置会话信息。

![]( {{site.url}}/asset/software-debugging-windbg-login-session.png )

目前，会话上下文只有在内核调试时才有意义，所以 !session 和 !sprocess 命令也只有在调试内核目标时才能使用。

### 进程上下文

所谓进程上下文就是指当前操作所基于的进程语境。

我们知道，Windows 系统中的内核空间是共享的，但用户空间是独立的。例如在 32 位 Windows 系统中，每个进程的进程空间是 4GB, 高 2GB 是内核空间，低 2GB 是用户空间，在同一个系统中，所有进程的高 2GB 内存空间都是相同的，但是低 2GB 空间是各自独立的。

在内核调试时，如果要观察内核空间的数据，那么不必关心当前进程是哪个，但如果要观察用户空间的数据，就必须注意当前进程是不是要观察的进程。

当调试目标中断到调试器之后，WinDBG 会根据调试事件的内容将相关的进程设置为默认进程。如果要观察其他进程的用户空间，那么必须先将进程上下文切换到那个进程。WinDBG 的 .process 命令用来观察和设置默认进程，例如以下命令将进程 83f7fc78 设置为默认进程：

```
1: kd> .process 83f7fc78
Implicit process is now 83f7fc78
```

其中 83f7fc78 是进程 EPROCESS 结构的地址。使用 !process 0 0 命令可以列出系统中所有进程的基本信息，其中就包含了 EPROCESS 结构的地址。

另一个有关的命令时 .context, 它可以设置或者显示用来翻译用户态地址的页目录基地址 (Base of Page Directory)。例如以下命令显示当前使用的页目录基地址 (物理地址)：

```
kd> .context
User-mode page directory base is a6750000
```

当调试用户态目标时，所有虚拟地址都是相对于当前进程的，不需要切换进程上下文，因此 .process 和 .context 命令都只能用在内核态调试会话中。

### 寄存器上下文

所谓寄存器上下文 (Register Context) 就是寄存器取值所基于的语境。因为一个 CPU 只有一套寄存器，所以当它轮番执行系统中的多个任务 (线程) 时，CPU 寄存器中存放的是当前正在执行线程的寄存器值。对于没有执行的线程，它的寄存器值保存在内存中，当 CPU 要执行这个任务时，这些寄存器值被从内存加载到物理寄存器中。

当我们在调试器中观察一个线程的寄存器时，这个线程是处于挂起状态的，所以我们看到的寄存器都是保存在内存中的寄存器值，而不是此时物理寄存器的值。当我们修改寄存器时，也是修改保存在内存中的寄存器值。

系统在一下几种情况下会将 CPU 中的寄存器值保存到当前线程的上下文记录 (Context Record) 中：
- 当系统做线程切换时，系统会将要挂起的线程的寄存器取值保存到内存中，这个上下文常被称为线程上下文；
- 当发生中断或异常时，系统会将当时的寄存器取值保存起来，这个上下文常被称为异常上下文；

### 局部变量上下文

所谓局部上下文 (Local Context) 就是指局部变量所给予的语境。局部变量是指定义在函数内部的变量，这些变量的含义与当前的执行位置密切相关。在调试时，调试器默认显示的是当前函数 (程序指针) 所对应的局部上下文。因为当前函数和局部变量都是与栈密切相关的，所以 WinDBG 调试器通常使用栈帧号来代表局部上下文。

使用不带参数的 .frame 命令可以观察当前的局部上下文，例如：

```
0:000> .frame
00 0012fdb4 7e418724 UefWin32!WndProc+0xe1 [C:\...\UefWin32.cpp @ 151]
```

这说明当前栈帧对应的函数是 WndProc, 此时使用 dv 命令可以显示这个函数的参数和局部变量：

```
0:000> dv
        rt = struct tagRECT
        hwnd = 0x002d0500 ...
```

使用 .frame 加上栈帧号可以将局部上下文切换到指定的栈帧，例如：

```
0:000> .frame 5
05 0012ff30 004018b3 UefWin32!WinMain+0xf3 [C:\...\UefWin32.cpp @ 48]
```

此时可以使用 dv 命令来显示这个函数的参数和局部变量：

```
0:000> dv
        hInstance = 0x00400000
        hPrevIntance = 0x00000000 ...
```


## 调试符号

本节讨论如何在 WinDBG 调试器中使用调试符号，包括加载调试符号，设置调试符号选项以及解决有关的问题。

### 重要意义

调试符号 (Debug Symbols) 是调试器工作的重要依据，保证调试符号的准确对于调试器的正常工作非常重要。如果缺少调试符号或调试符号不匹配，那么调试器可能显示出错误的结果。

### 符号搜索路径

大多数调试任务都涉及到多个模块，不同模块的调试符号的位置也很可能不在同一个位置上。为了方便调试，WinDBG 允许用户指定一个目录列表，当需要加载符号文件时，WinDBG 会从这些目录中搜索合适的符号文件。这个目录列表被称为符号搜索路径，简称符号路径 (Symbol Path)。

在符号路径中可以指定两种位置，一种是普通的磁盘目录或网络共享目录的完整路径；另一种是符号服务器，多个位置间使用分号分隔。

可以有一下几种方法来设置符号路径：

- 设置环境变量 `_NT_SYMBOL_PATH` 和 `_NT_ALT_SYMBOL_PATH`；
- 启动调试器时，在命令行中使用 -y 开关来定义；
- 使用 .sympath 命令来增加、修改或显示符号路径，例如 `.sympath + c:\folder` ；
- 使用 .symfix 命令来自动设置符号服务器；
- 使用 File 菜单的 Symbol File Path 来设置；

执行不带任何参数的 .sympath 命令可以显示当前已有的符号路径；

### 符号服务器

调试时涉及到的模块很可能属于不同的开发部门或公司，一个模块通常有很多个不同的版本，所以调试时为每个模块找到正确的符号文件不是一件简单的事。

解决上述问题的一个有效方法是使用符号服务器 (Symbol server)。

![]( {{site.url}}/asset/software-debugging-windbg-symbol-server.png )

为了避免重复下载以前下载过的符号文件，符号服务器 DLL 会将下载好的文件保存到本地的一个文件夹中，这个文件夹使用与符号服务器上相似的方式来组织符号文件，称为下游符号库。当符号服务器 DLL 接收到 DbgHelp 的请求需要某个符号文件时，符号服务器 DLL 会先从下游符号库中查找，如果找不到才到远程的中央符号库去查找。

### 观察模块信息

可以使用以下方法之一来观察模块信息，包括加载符号文件的情况
- 使用 lm 命令；
- 使用 !lmi 扩展命令；
- 使用 WinDBG 图形界面的模块列表对话框 (Debug --> Modules)；

### 检查符号

可以使用标准命令 x 来检查调试符号，其命令格式如下：

```
x [选项] 模块名!符号名
```

其中的模块名和符号名都可以包含通配符，* 代表 0 或任意多个字符， ? 代表任一个单一字符， # 表示它前面的字符可以出现任意多次，比如 lo#p 表示所有以 l 开头，以 p 结尾，中间有多个 o 的字符；例如 `x ntdll!dbg*` 可以列出 ntdll 中所有以 dbg 开头的符号。

### 搜索符号

标准命令 ln (List Nearest Symbols) 用来搜索距离指定地址最近的符号，比如：

```
lkd> ln 8053ca11
(8053ca11) nt!KiSystemService | (8053ca85) nt!KiFastCallEntry2
Exact matches:
        nt!KiSystemService = <no type information>
```

上述命令显示了距离 8053ca11 最近的两个符号，其中 nt!KiSystemService 与指定的地址精确匹配。

### 设置符号选项

元命令 .symopt 用来显示和修改符号选项，其格式为：

```
.symopt [+/- 选项标志]
```

目前定义的标志位包括：

![]( {{site.url}}/asset/software-debugging-windbg-symopt.png )

### 加载不严格匹配的符号文件

在实际工作中，有时候要调试的程序只是做了简单的重新构建，代码仅有微小的变化或根本没有变化。这时，如果调试环境中只有就的符号文件，那么调试器默认仍会因为符号文件和映像文件不匹配而拒绝加载符号文件。

一种方法是使用 .reload /i 命令来加载不完全匹配的符号文件。为了发现问题，最好先使用 !sym noisy 命令开启加载符号的 “吵杂” 模式，这种情况下可以看出符号不匹配的详细信息。

另一种方法是通过设置符号选项 `SYMOPT_LOAD_ANYTHING(0X40)` 来让调试器加载不严格匹配的符号文件。


## 事件处理

Windows 的调试模型是事件驱动的。整个调试过程就是围绕调试事件的产生、发送、接收和处理为线索而展开的。

调试目标时事件的发生源，调试器负责接收和处理调试事件，调试子系统负责将调试事件发送给调试器并为调试器提供服务。

### 调试事件与异常的关系

简单来说，异常是调试事件的一种。

Windows 定义了 9 类调试事件：
- `EXCEPTION_DEBUG_EVENT`;
- `CREATE_THREAD_DEBUG_EVENT`;
- `CREATE_PROCESS_DEBUG_EVENT`;
- `EXIT_THREAD_DEBUG_EVENT`;
- `EXIT_PROCESS_DEBUG_EVENT`;
- `LOAD_DLL_DEBUG_EVENT`;
- `UNLOAD_DLL_DEBUG_EVENT`;
- `OUTPUT_DEBUG_STRING_EVENT`;
- `RIP_EVENT`;

因为有很多种异常，所以异常事件又根据异常代码分为很多子类，常见的异常子类有：
- Win32 异常，这是 Windows 操作系统所定义的异常，包括 CPU 产生的异常和系统内核代码所产生的异常，典型的有除零异常、非法访问等。
- Visual C++ 异常，这是 Visual C++ 编译器的 throw 关键字抛出的异常，throw 关键字调用 RaiseException API 来产生异常，所有这类异常的异常代码都是 0xe06d7363(.msc)；
- 托管异常，这是 .Net 程序使用托管方法抛出的异常，所有这类异常代码都是 0xe0636f6d(.com)；
- 其他异常，包括用户程序直接调用 RaiseException API 抛出的异常，以及其他 C++ 编译器抛出的异常等；

### 两轮机会

我们之前介绍异常管理时，曾经详细讨论过 Windows 操作系统分发和处理异常的流程，其中最重要的一点是，对于每个异常，Windows 最多会给予两轮处理机会。对于每一轮处理机会，Windows 都会先尝试分发给调试器，然后再寻找异常处理器 (VEH, SEH 等)。这样看来，对于每个异常，调试器最多可能收到两次处理机会，每次处理后调试器都应该向系统返回一个结果，说明它是否处理了这个异常。

对于第一轮异常处理机会，调试器通常返回没有处理异常，然后让系统分发，交给程序中的异常处理器来处理。对于第二轮机会，如果调试器不处理，那么系统便会采取终极措施：如果异常发生在应用程序中，那么系统会启动应用程序错误报告过程并终止应用程序；如果发生在内核代码中，那么便启用蓝屏机制停止整个系统。

所以对于第二轮异常处理机会，调试器通常返回已经处理，让系统恢复程序继续执行，这通常会导致异常再次发生，又重新分发异常，如此循环。

WinDBG 把异常和其他调试事件放在一起来管理，但是必须清楚的是，只有异常事件有两轮处理机会，异常以外的其它调试事件(比如进城创建)都只有一轮处理机会。

### 定制事件处理方式

大多数调试器都允许用户来定制处理调试事件的方式，WinDBG 也是如此。因为异常事件最多有两轮处理机会，而且对于每一轮机会都需要决定如下两个问题：

- 当收到事件通知后是否中断给用户 (进入到命令模式)；
- 返回给系统的处理结果，是返回已经处理 (handled), 还是没有处理 (not handled), 即所谓的处理状态 (handling status), 有时候也称为继续状态 (continue status)；

所以对于每种异常事件存在以下四个选项：
- 第一轮处理机会是否中断给用户；
- 第二轮处理机会是否中断给用户；
- 第一轮机会的处理结果；
- 第二轮机会的处理结果；

前两个选项被称为中断选项，后两个被称为继续选项。

WinDBG 中可以通过 Debug --> Event Filter 菜单打开事件过滤对话框，对事件处理方式进行设定：

![]( {{site.url}}/asset/software-debugging-windbg-event-filter.png )

右下角 Execution 框中包含了 4 个选项：
- Enabled : 收到该事件后便中断给用户，对于异常事件，两轮机会都会中断给用户；对于其他调试事件，意味着收到时便中断；
- Disabled : 对于异常事件，第二轮机会时中断给用户，第一轮不中断。对于其他调试事件，不中断到命令模式；
- Output : 输出信息通知用户；
- Ignore : 忽略这个事件；

Continue 框中的两个选项用于配置返回给系统的异常事件处理状态，只适用于异常类事件，而且是针对第一轮处理机会的。如果选择 Handled, 那么便返回已经处理异常，否则返回没有处理异常。

### GH 和 GN 命令

当因为发生异常而中断到调试器时，如果使用 g 命令恢复调试目标执行，那么调试器将使用上面介绍的配置来决定返回给系统的处理状态。如果调试人员希望返回与设置不同的状态，那么可以使用 GH 和 GN 命令。GH 用来强制返回已经处理 (Handled), GN 用来强制返回没有处理 (Not Handled)。


## 控制调试目标

### 初始断点

当调试一个新创建的进程时，为了让调试人员可以尽可能早地分析调试目标，Windows 操作系统的进程加载器加入了特别的调试支持，在完成最基本的用户态初始化工作后，系统的模块加载函数就会主动执行断点指令，触发断点，让调试目标中断到调试器中。这个断点被称为初始断点 (Initial Breakpoint)。

当将 WinDBG 附加到一个已经运行的进程时，WinDBG 默认也会通过在目标进程中创建一个远程线程的方式来触发一个断点，这个断点发生在新创建的线程上下文中，其栈调用通常为：

```
0:001> kn
# ChildEBP RetAddr
00 00cdffc8 7c9507a8 ntdll!DbgBreakPoint
01 00cdfff4 00000000 ntdll!DbgUiRemoteBreakin + 0x2d
```

值得注意的是，这个线程并不是目标进程的本来线程，它是调试器创建的。当我们恢复目标执行时，这个线程也会立刻退出。

### 俘获调试目标

初始断点为我们分析被调试程序提供了一个初始机会，通常设置了断点或者做基本的准备工作后，我们便恢复目标继续执行。如果希望把运行的调试目标再次中断到调试器中，那么可以使用如下方法：
- 在调试器界面选择中断指令 (Debug --> Break) 或者使用 Ctrl + Break 热键，其原理也是通过远程线程来设置断点；
- 对于有窗口界面的程序，将被调试程序窗口切换到前台，然后按 F12 热键；
- 如果已经设置了断点，或者在代码中加入了触发异常的代码，那么可以执行相应的操作，让程序触发断点或异常，使其中断到调试器；

### 继续运行

WinDBG 提供了很多命令来让调试目标恢复继续运行，最常用的就是 g(go) 命令。热键 F5 和 Debug 菜单中提供的 Go 菜单项对应的就是 g 命令，其形式一般为：

```
g[a] [= StartAddress] [BreakAddress ... [; BreakCommands]]
```

其中 StartAddress 用来指定恢复执行的起始地址，默认为当前位置，BreakAddress 用来指定一个断点地址，BreakCommands 用来指定断点指令命中后所执行的命令。使用开关 a 将断点设置为硬件断点。

如果指定了断点地址 BreakAddress, 那么 WinDBG 会设置一个隐蔽的断点，然后恢复目标执行，当执行到这个断点时，WinDBG 中断并自动删除这个断点。

当使用汇编或源代码窗口时，可以使用 “运行到光标处” (Run to Cursor) 命令 (Ctrl + F10 或者菜单 Debug --> Run to Cursor) 来执行到光标所在位置，这其实就是利用 g 命令加断点地址来实现的。

另外， gu 命令用来执行到上一级函数，即执行完当前函数，返回到上一级函数。


## 单步执行

### 概览

根据的当前是否处于源代码模式 (Source Mode), 单步跟踪分为源代码级的单步和汇编指令一级的单步。

通过 Debug --> Source Code 菜单或者执行 l+t 命令可以进入源代码模式，反选 Source Code 菜单项或者执行 l-t 命令可以退出源代码模式，进入汇编模式。

如果当前的指令或者代码行包含了函数调用，那么有两种选择，一种是跟踪进入要调用的函数，另一种是忽略要调用函数的执行过程，让其执行完毕后再停下来。前一种方式称为单步进入 (Step Into), 后一种方式称为单步越过 (Step Over)。

在 WinDBG 中，使用单步 (Step) 一词来指代前一种方式，命令为 p; 使用跟踪 (Trace) 一词来指代后一种方式，命令为 t. 如果不包含函数调用，这两个命令效果是一样的。

除了基本功能外，还可以通过向 p 和 t 命令附带参数来使用附加功能，这两个命令的完整语法为：

```
p|t [r] [= StartAddress] [Count] ["Command"]
``` 

r 的作用是禁止自动显示寄存器内容；StartAddress 可以让程序从一个新的地址开始执行，这会跳过中间代码，可能导致栈平衡被打破；Count 用于指定单步执行的次数；Command 用于指定单步执行结束后要执行的命令，例如 `p "kb"` 表示单步执行后自动执行 kb 命令。

### 单步执行到指定地址

WinDBG 提供了 pa 和 ta 命令用来执行到执行的地址，其命令格式为：

```
pa|ta [r] [= StartAddress] StopAddress
```

其中 pa 是 Step to Address 的缩写，即单步执行到 StopAddress 参数所代表的地址处的指令，如果中间有函数调用，那么不进入所调用的函数。在执行过程中，WinDBG 会显示程序执行的每一步，其效果相当于反复执行 p 命令。 ta 命令与 pa 命令类似，只不过遇到函数时会进入到函数中，而不是越过，这和 t 命令与 p 命令的差异是一样的。

### 单步执行到下一个函数调用

pc 和 tc 命令 用于单步执行到下一个函数调用指令 (call), 其命令格式为：

```
pc|tc [r] [= StartAddress] [Count]
```

### 单步执行到下一分支

使用 tb 命令可以实现分支到分支的单步执行：

```
tb [r] [= StartAddress] [Count]
```

### 追踪并监视

如果我们想了解一个函数的执行路径和它调用了哪些函数，以及每个函数中包含了多少条指令，但我们又不想一步步地跟踪执行，那么可以使用 wt 命令让它帮我们跟踪执行并生成一份报告：

![]( {{site.url}}/asset/software-debugging-windbg-wt-command.png )

从上图可以看出，main 函数首先调用了 GetRandom 函数，随后又调用了 GetVersion 函数。

### 归纳

下图归纳了文中提到的控制目标程序执行的指令：

![]( {{site.url}}/asset/software-debugging-windbg-target-control-command.png )


## 使用断点

### 软件断点

简单来说，软件断点就是通过将指定位置的指令替换为断点指令 INT3 而设置的断点。WinDBG 设计了 3 条命令来设置软件断点，分别是 bp, bu, bm. 其中 bp 是最常用的，其命令格式如下：

```
bp [ID] [Options] [Address [passes]] ["Command"]
```

ID 用来指定断点编号，如果不指定，WinDBG 会自动分配一个；Options 用来指定选项；Address 用来指定断点地址；Passes 用来指定因为这个断点而中断到命令模式所需的穿越(命中)次数。

例如以下命令可以在 printf 函数的入口偏移 3 的地址处设置一个断点，当 CPU 第二次 “穿越” 这个位置时中断给用户，并自动执行 kv 和 da poi(ebp+8) 指令：

```
bp MSVCR80D!printf+3 2 "kv;da poi(ebp+8)"
```

bu 命令用来设置一个延迟的以后再落实的断点，用于对尚未加载模块中的代码设置断点。当指定模块被加载后，WinDBG 会真真落实这个断点。所以 bu 命令对于调试动态加载模块的入口函数或初始化代码特别有用。例如，当调试即插即用设备的驱动程序时，因为驱动程序是由操作系统的 I/O 管理模块动态加载的，当我们发现它加载时，入口函数和初始化代码已经执行完了。对于这种情况，就可以使用 bu 命令在驱动加载前就对它设置一个断点，即 `bu MyDriver!DriverEntry`

bm 命令用来设置一批断点，相当于很多次执行 bp 或 bu 命令。比如以下命令对 msvcr80d 模块中的所有 print 开头的函数设置断点：

```
bm msvcr80d!print*
```

### 硬件断点

硬件断点就是通过 CPU 的硬件寄存器设置的断点。硬件断点具有数量限制，但是可以实现软件断点不具有的功能，比如监视数据访问和 I/O 访问等。

WinDBG 使用 ba 命令设置硬件断点，其格式如下：

```
ba [ID] Access Size [Options] [Address [Passes]] ["Command"]
```

Access 用来指定断点的访问方式，可以为以下几个字母之一：
- e : 当从指定地址读取和执行指令时，触发断点，这种断点又称为访问代码硬件断点。跟软件断点的效果是类似的，但不需要做指令替换和恢复；
- r : 当从指定地址读取和写入数据时，触发断点；
- w : 当向指定地址写入数据时，触发断点；通过 r 和 w 设置的断点又称为数据访问断点；
- i : 当向指定地址执行输入输出访问 (I/O) 时触发断点，对于 x86 架构，IN 和 OUT 指令用于读写 IO 端口，这种断点又称为 I/O 断点。

### 条件断点

可以在设置断点时通过 j 命令或者 `.if ... .else` 命令来设置条件断点：

```
bp|bu|bm|ba Address "j (Condition) 'OptionalCommands'; 'gc'"
bp|bu|bm|ba Address ".if (Condition) {OptionalCommands} .else {gc}"
```

其中 Condition 用来定义希望中断的情况，OptionalCommands 用来定义关心的情况发生后中断到命令模式时顺便执行的指令。举例来说，以下是使用 j 命令设置的条件断点：

```
bp dbgee!wmain "j (poi(argc)>1) 'dd argc l1; du poi(poi(argv)+4)'; 'gc'"
```

这个命令对 dbgee 程序的 wmain 函数设置一个断点，只有当命令行参数的个数大于 1 时，才中断给用户，中断时执行两条命令，一条是 `dd argc l1`, 用来显示 argc 参数的值，另一条是 `du poi(poi(argv)+4)`，用来显示第一条命令行参数的字符串内容。

其中 poi 是 MASM 表达式支持的特殊运算符，其含义是从指定地址取指针长度数据 (Pointer-sized data)

### 地址表达方法

可以使用以下 3 种方法来指定断点命令中的地址参数：
- 使用模块名加函数符号的方式，比如 `bp dbgee!wmain` 代表对 dbgee 模块中的 wmain 函数设置断点，也可以在符号后面增加一个偏移值，比如 `bp dbgee!wmain+3`；
- 直接使用内存地址，例如 `bp 00411390`；
- 如果是使用完全的调试符号，符号中包含源代码行信息，那么可以使用如下形式 `[[Module!]FileName][:LineNumber]` 整个表达式应当用两个重音符号 (`) 包围起来；
- 对于 C++ 的类方法，也可以使用类名双冒号 (::) 或双下划线 (__) 来连接类名和方法名，比如 `bp MyClass__MyMethod`；

### 设置针对线程的断点

对于多线程程序，如果有多个线程都会调用某个函数，有时候我们会希望只有在指定线程调用这个函数时才中断到调试器。为了满足这一需要，WinDBG 的软件断点设置命令支持在命令前面加上线程限定符，即 `~` 加线程符号。例如：

```
~0 bp MSVCR80D!printf
```

### 管理断点

使用 bl 命令可以列出所有断点。

bc, bd, be 分别用来删除、禁止、启用断点，它们的格式都是：

```
bc|bd|be 断点 ID
```

可以使用 * 来匹配所有断点，例如 `bc *` 删除所有断点。


## 控制进程和线程

### 控制线程执行

通常，当被调试程序被中断到调试器中时，它的所有线程都是被挂起的；当恢复执行时，所有线程都被恢复执行。但是在调试时，可以根据调试任务的需要而保持某些线程仍然处于停止运行状态。

第一种方法是通过增加线程的挂起计数来禁止线程被恢复运行。当调试目标中断到调试器中时，WinDBG 会对所有线程依次调用 SuspendThread API, 当恢复程序执行时，再对所有线程调用 ResumeThread API. 

可以使用 `~Thread n` 命令来增加对 Thread 线程的挂起计数，例如 `~1 n` 将 1 号线程的挂起技术增加为 2. 此时输入 g 命令继续执行，会发现只有 0 号线程被恢复了， 1 号线程仍然处于挂起状态；

与 `~Thread n` 命令相对， `~Thread m` 命令用来减少线程的挂起计数。实际上这两个命令分别调用了 SuspendThread 和 ResumeThread API。

控制线程执行的第二种方法是使用 `~f` 和 `~u` 命令，前者用来冻结 (freeze) 一个线程，后者则用来解冻 `Unfreeze`。

控制线程执行的第三种方法是在恢复执行的命令前通过线程限定符和线程号码只恢复执行指定的线程，比如不管目标程序有多少个线程，命令 `~0 g` 都只恢复 0 号线程继续执行。

### 多进程调试

WinDBG 支持使用一个调试器来调试多个进程，这些进程可以在一个系统上，也可以在多个系统上。

这里不多做介绍了，具体可以参考原文。