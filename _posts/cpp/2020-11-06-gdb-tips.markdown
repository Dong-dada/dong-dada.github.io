---
layout: post
title:  "C++ - GDB 小技巧"
date:   2020-11-06 11:00:30 +0800
categories: cpp
---

* TOC
{:toc}

编译成可执行文件后，直接运行 `gdb ${文件路径}`，就可以调试该程序。


# 常用命令

| 命令 | 说明 | 示例 |
|:--|:--|:--|
| b(break) | 设置断点 | `b src/main.cc:123` |
| r(run) | 启动程序，可传入参数 | `r --test_filter=MainTest:Basic` |
| info b | 查看断点列表 | |
| delete | 按照序号删除断点 | `delete 1-10` 删除 1~10 序号的断点 |
| c(continue) | 执行到下个断点 | |
| n(next) | 执行下一行 | |
| s(step) | 尝试进入函数 | |
| finish | 运行直到当前函数返回 | |
| p(print) | 打印变量 | `p str.c_str()` |
| bt | 查看调用栈 | |
| set args | 设置命令行参数 | |
| show args | 查看命令行参数 | |
| l(list) | 显示当前代码，默认显示 10 行 |  |
| display | 设置一个表达式，每次单步运行后，都会打印出表达式的值 | `display str` |
| watch | 监视一个表达式，表达式的值改变后，程序会终端 | `watch str` |
| q(quit) | 退出调试 | |
| call | 调用一个函数 | `call test(123)` |
| shell | 执行 shell 程序，比如清屏 | `shell clear` |


# 设置命令行参数

启动 gdb 后，可以使用 set args 命令设置命令行参数:

```
(gdb) set args abc
```

另外一种方式是在运行 `run` 命令的时候附加命令行参数:

```
(gdb) run abc
```


# 保存断点

使用 `save breakpoint` 命令可以将断点保存到一个文件当中:

```
(gdb) save breakpoint main.bp
```

下次启动调试的时候，通过 `-x` 参数指定断点文件，这样就会加载之前保存的断点文件:

```
gdb bin/main -x main.bp
```


# STL pretty printer

给 GDB 安装 STL 支持插件，就可以在 GDB 调试时看到 STL 容器的内容。安装方法如下:

下载插件到合适的位置

```
svn co svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python
```

编辑 ~/.gdbinit 文件，添加以下内容(注意 /home/maude/gdb_printers/python 需要替换成插件文件夹所在位置):

```
python
import sys
sys.path.insert(0, '/home/maude/gdb_printers/python')
from libstdcxx.v6.printers import register_libstdcxx_printers
register_libstdcxx_printers (None)
end
```


# 显示 shared_ptr 内容

打印 shared_ptr 等结构时，可以先把 shared_ptr 打印出来，找到对象类型和目标地址。随后通过 `p *(${Type})${Address}` 这样的命令来打印指针指向的对象:

```
(gdb) p order
$1 = warning: RTTI symbol not found for class 'std::_Sp_counted_ptr_inplace<Order, std::allocator<Order>, (__gnu_cxx::_Lock_policy)2>'
warning: RTTI symbol not found for class 'std::_Sp_counted_ptr_inplace<Order, std::allocator<Order>, (__gnu_cxx::_Lock_policy)2>'
std::shared_ptr<Order> (use count 1, weak count 0) = {get() = 0x417e80}

(gdb) p *(Order*)0x417e80
$2 = {id = 10, product_name = "Lumia 950"}
```

如上，先从 order 这个 `shared_ptr` 变量中找到类型 `Order` 和地址 `0x417e80`，然后通过 `p *(Order*)0x417e80` 命令查看对象内容。


# LLDB 命令

LLDB 和 GDB 的命令挺像的，[这份文档](https://lldb.llvm.org/use/map.html) 是两者的对比。