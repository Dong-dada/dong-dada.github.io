---
layout: post
title:  "《软件调试》 学习 05 Windows 概要"
date:   2017-04-07 16:22:30 +0800
categories: debugging
---

* TOC
{:toc}

本文将介绍 Windows 操作系统的基本知识和概念，包括访问模式、进程和线程、以及 Windows 的架构和核心部件。

## 进程和进程空间

程序和进程的关系好比是类和实例的关系，当我们运行一个程序时，操作系统就会为这个程序创建一个实例，也就是进程。

从操作系统的角度来讲，每个进程又被称为一个任务(task)。值得说明的是，因为每个 Windows 进程可以包含一个到多个线程，每个线程都可以被调度执行，所以 Windows 系统中的任务与 CPU 一级的任务是不同的。CPU 一级的任务相当于 Windows 系统下每个进程的一个线程。操作系统中的任务是指系统中运行的各个进程，从这个意义上讲，Windows 操作系统中的每个任务对应于 CPU 的一个或多个任务。

为了保证系统中每个任务和进程的安全，Windows 为不同的进程分配了独立的进程空间(process space)。进程空间是操作系统分配给每个进程的虚拟内存空间(virtual address space)，每个进程运行在这个受操作系统保护的空间之内，它的程序指针所代表的是本进程空间中的一个虚拟地址，根本无法指到另一个进程空间中的数据，这样便保证了一个进程的数据和代码不会轻易地受到其他进程的侵害。

对于 32 位的 x86 系统，每个进程的进程空间是 4GB，即地址 `0x00000000` 到地址 `0xFFFFFFFF`。为了高效地调用和执行操作系统中的各种服务，Windows 会把操作系统的内核数据和代码映射到系统中所有进程的地址空间中。因此 4GB 的进程空间总是被划分为两个区域：用户空间和系统空间。默认情况下，低 2GB 为用户空间，高 2GB 为系统空间。

除了虚拟地址空间，每个 Windows 进程还拥有：
- 一个全局唯一的进程 ID，简称为 PID；
- 一个可执行映像(image), 也就是该进程的程序文件(可执行文件)在内存中的表示；
- 一个或多个线程；
- 一个位于内核空间中的名为 EPROCESS(executive process block, 即程序执行块)的数据结构，用以记录该进程的关键信息，包括进程创建时间、映像文件名称等；
- 一个位于内核空间中的对象句柄表，用于记录和索引该进程所创建/打开的内核对象。操作系统会根据这个表格把用户模式下的句柄翻译为执行内核对象的指针；
- 一个用于描述内存目录表起始位置的基地址，简称 页目录基地址(DirBase)，当 CPU 切换到该进程/任务时，会将该地址加载到 CR3 寄存器，这样当前进程的虚拟地址才会被翻译为正确的物理地址；
- 一个位于用户空间中的进程环境块(Process Environment Block, 简称 PEB)；
- 一个访问权限令牌(access token)，用于表示该进程的用户、安全组、以及优先级别；

### SessionID

进程的 SessionID 是指该进程所在的 Windows 会话(Session) 的 ID 号。当有多个用户同时登陆时，Windows 会为每个登陆用户建立一个会话，每个会话都有自己的 WorkStation 和桌面(Desktop)。这样大家便可以工作在不同的 “会话” 中共同使用同一个 Windows 系统。对于典型的 XP 系统，当只有一个用户登录时，用户启动的程序和系统服务都运行在 Session 0, 当切换到另一个用户账号时 (Switch User, 不是 Log off)，系统会建立 Session 1，以此类推。为了提高系统服务的安全性，Vista 只允许系统服务运行在 Session 0, 因此一旦登录到 Vista 中，我们就会看到有两个会话，有两个 Windows 子系统进程 (csrss.exe) 在运行。

下图是使用 Win7 登录两个用户后的任务管理器截图，可以看到此时存在三个 `csrss.exe` 进程。它们的 Session ID 依次为 0, 1, 2。

![]( {{ site.url }}/asset/software-debugging-sessionid.png )


## 内核模式和用户模式

根据上一节的介绍，Windows 会把操作系统的代码和数据映射到系统中所有进程的系统空间中。这样，用户空间中的程序指针便可以指向系统空间中的数据和代码。那么如何防止系统空间中的操作系统数据或代码被破坏呢？答案是利用权限控制来实现对系统空间的保护。

### 访问模式

Windows 定义了两种访问模式(access mode)：用户模式(user mode) 和 内核模式(kernel mode)。应用程序运行在用户模式下，操作系统代码运行在内核模式下。内核模式对应于处理器的最高权限级别，在内核模式下执行的代码可以访问所有系统资源并具有使用所有特权指令的权利。相对而言，用户模式对应于较低的处理优先级，在用户模式下执行的代码只能放问系统允许其访问的内存空间，并且没有使用特权指令的权利。

前面介绍过 IA-32 定义了 4 中特权级别，分别为 Ring0, Ring1, Ring2, Ring3。处理器在硬件级别保证了高优先级的数据不会被低优先级的破坏。Windows 使用了这 4 种优先级中的两种，Ring0 用于内核模式，Ring3 用于用户模式。

因此用户程序只能通过调用系统服务来间接执行系统空间中的代码。当调用系统服务时，调用线程会从用户模式切换到内核模式，调用结束后再返回到用户模式，也就是所谓的模式切换，有时也被称为上下文切换 (Context Switch)。在每个线程的 KTHREAD 结构中，有一个名为 ContextSwitches 的字段，专门用来记录这个线程的模式切换次数。模式切换是通过软中断或专门的快速系统调用 (Fast System Call) 指令来实现的。

#### 使用软中断 INT 2E 切换到内核模式

下图画出了在 Windows 2000 中从应用程序调用 `ReadFile()` API 的过程：

![]( {{ site.url }}/asset/software-debugging-int-2e.png )

- 因为 `ReadFile()` 是从 `Kernel32.dll` 中导出的，所以首先转到 `Kernel32.dll` 中；
- `Kernel32.dll` 对参数进行简单检查后便调用 `NTDll.dll` 中的 `NtReadFile()` 函数；
- `NtReadFile()` 首先将一个服务号 `0xa1` 放入寄存器，接着把参数放入寄存器，然后便通过 `INT n` 指令发出调用，其中 n 的值是 `2E`；
- CPU 通过 IDT(中段描述符表) 找到 `2E` 向量号对应的中断处理例程 `KiSystemService` 函数；
- 由于 `KiSystemService` 函数位于内核空间中，所以 CPU 在把执行权交给它之前会先做好从用户态切换到内核态的准备：
    - 权限检查，核实是否可以进行切换；
    - 准备内核态使用的栈，为了保证内核安全，所有线程在内核态执行时都必须使用位于内核空间中的内核栈(kernel stack)，内核栈一般大小为 8KB 或 12KB；
- `KiSystemService` 通过寄存器中实现存好的服务号 `0xa1` 从系统服务分发表 (System Service Dispatch Table) 中查找到要调用的服务函数地址和参数描述，然后将参数从用户态复制到该线程的内核栈中；
- `KiSystemService` 调用内核中真正的 `NtReadFile()` 函数，执行读取文件的操作；
- 操作结束后会返回到 `KiSystemService`, 它将操作结果复制回该线程的用户态栈；
- 通过 IRET 指令将执行权交回给 `NtDll.dll` 中的 `NtReadFile()` 函数，继续执行接下来的指令；

通过 INT 2E 进行系统调用时， CPU 必须从内存中分别加载门描述符和段描述符后才能找到 `KiSystemService` 的地址，然后进行权限检查。

因为系统调用是非常频繁的操作，如果能用特殊的指令让 CPU 省去那些对系统服务调用来说根本不需要的权限检查的话，可以提升系统的速度。为此奔腾 II 处理器中引入了 `SYSENTER/SYSEXIT` 指令，这些指令可以加快系统调用的速度，因此利用这些指令完成的系统调用被称为快速系统调用(Fast System Call)。

#### 快速系统调用 

这部分就不介绍了，思路跟上面是类似的。只不过使用快速调用指令可以节省权限检查这一步骤。


## 系统架构和部件

本节介绍 Windows 系统的总体架构和重要的系统部件。

### 内核空间

从职能角度看，内核空间主要包含以下部件：
- 硬件抽象层(Hardware Abstraction Layer)，简称 HAL。HAL 的主要作用是隔离硬件差异性，使内核和顶层模块可以通过统一的方式来访问硬件；
- 操作系统内核，负责线程调度、中断处理、异常分发、多处理器同步等关键任务，是操作系统最核心的部分；
- 执行体 (Executive)，执行体包含了操作系统的基本服务，包括内存管理、进程管理、输入输出(I/O)、网络和进程间通信等。如果把操作系统内核比喻成系统的最高权力机构，那么执行体就是它的一个个职能部门，负责各方面的事务；
- 内核态驱动程序，包括文件系统和图形显示驱动程序，以及用于其他硬件的驱动程序。驱动程序是对内核功能的补充；
- Windows 子系统驱动程序 (Win32K.SYS)，包括 USER 和 GDI 两部分，USER 负责窗口管理、用户输入等，GDI 负责显示输出和各种图形操作；
- 内核支持模块，包括用于内核调试的 KDCOM.dll，用于启动阶段显示驱动的 BOOTVID.DLL 等；

#### 内核文件和 HAL 文件

我们上面说的操作系统内核和执行体都位于同一个文件中，一般叫做 NTOSKRNL.EXE，根据处理器数量不同，是否开启 PAE，文件名会有所不同。

HAL 存放在 HAL.DLL 文件中，也会根据不同的硬件平台有不同的名字。

#### 系统和 IDLE 进程

在内核空间中，有两个特殊的进程 系统进程(System Process) 和 空闲进程 (Idle Process)。之所以说它们特殊，是因为它们具有如下特征：
- 普通的 Windows 进程都是通过 CreateProcess API 并指定一个可执行映像文件而创建的，但这两个进程没有映像文件，而是在系统启动时 “捏造” 出来的；
- 普通的 Windows 进程都有用户态和内核态两个部分，但是这两个进程都只有内核态的部分，或者说它们只在内核态执行；
- 固定的进程 ID，Idle Process 的进程 ID 是 0，System Process 的进程 ID 是 8 或 4；

简单来说， System Process 是系统内核和大多数系统线程的宿主和载体。在一个典型的 Windows 系统中，系统进程中有几十个乃至上百个系统线程在工作。

类似的，Idle Process 是 IDLE 线程的载体，IDLE 线程的个数与系统中启用的处理器个数是一致的。当 CPU 中没有其他线程需要执行时，CPU 会执行 IDLE 线程。第一个 IDLE 线程是从系统的初始化线程蜕化而来的，是系统中“年龄最大”的线程；

### 用户空间

从进程角度看，用户空间中运行着以下进程：
- 会话管理器进程 (SMSS.EXE)，它是系统中第一个根据文件映像创建的进程，它运行后，会加载和初始化 Win32 子系统的内核模块 Win32K.SYS，创建 Win32 子系统服务器线程 (CSRSS.EXE)，并创建登录进程；
- Windows 子系统服务器进程 (CSRSS.EXE)，负责维护 Windows 子系统的 “日常事务”，为子系统中的各个进程提供服务。例如登记进程和线程、管理控制台窗口、管理 DOS 程序虚拟机进程等。
- 登录进程(WinLogin.EXE)，专门负责用户登录和安全有关的事务。它启动后，会创建 LSASS 进程和系统服务管理进程 (Service.exe)。Windows XP 的文件保护功能 (Windows File Protection, 简称 WFP)也是在这个进程中实现的(sfc.dll 和 sfc_os.dll)；
- 本地安全和认证进程 (LSASS.EXE)，负责用户身份验证；
- 服务管理进程 (Service.exe), 负责启动和管理系统服务程序。系统服务程序是按照 NT 系统服务(NT Service)编写的 EXE 程序，通常没有用户界面，只在后台运行。
- OS/2 和 POSIX 子系统服务进程，用于在 Windows 系统中运行 OS/2 和符合 POSIX 标准的程序。
- 壳程序(Shell)，默认为 Explorer.exe，负责显示开始菜单、任务栏和桌面图标等；

#### NTDLL.DLL 

NTDLL.DLL 是沟通用户空间和内核空间的桥梁，用户空间的代码通过这个 DLL 来调用内核空间的系统服务(我们在上一节介绍过 `ReadFile()` 的调用过程)。同时，它也是操作系统内核在用户模式下的代理，系统会在启动阶段把它加载到内存中，并把它映射到所有用户进程的地址空间中，而且是映射在相同的位置。当内核需要用户空间的配合时，它会使用这个 DLL 作为着陆点。

